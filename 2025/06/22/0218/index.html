<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>[计算机网络]第五章-传输层 | BlankChen</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">[计算机网络]第五章-传输层</h1><a id="logo" href="/.">BlankChen</a><p class="description">相逢的人会再相逢。</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home">Home</i></a><a class="current" href="/notes/"><i class="fa fa-sticky-note-o"> Notes</i></a><a href="/thoughts/"><i class="fa fa-lightbulb-o"> Thoughts</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">[计算机网络]第五章-传输层</h1><div class="post-meta">2025-06-22<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 9.2k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 32</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2025/06/22/0218/#waline"><span class="waline-comment-count" id="/2025/06/22/0218/"></span><span> Comment</span></a><div class="post-content"><h1 id="5-1-传输层提供的服务"><a href="#5-1-传输层提供的服务" class="headerlink" title="5.1 传输层提供的服务"></a>5.1 传输层提供的服务</h1><h2 id="TCP-传输控制协议-Transmission-Control-Protocol"><a href="#TCP-传输控制协议-Transmission-Control-Protocol" class="headerlink" title="TCP: 传输控制协议 (Transmission Control Protocol)"></a>TCP: 传输控制协议 (Transmission Control Protocol)</h2><h2 id="UDP-用户数据报协议-User-Datagram-Protocol"><a href="#UDP-用户数据报协议-User-Datagram-Protocol" class="headerlink" title="UDP: 用户数据报协议 (User Datagram Protocol)"></a>UDP: 用户数据报协议 (User Datagram Protocol)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>传输层为运行在不同主机上的进程之间提供逻辑通信。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>网络的边缘部分的两台主机使用网络的核心功能进行端到端的通信时只有主机的协议栈才有传输层，而路由器在转发分组时都只用到下三层的功能。(传输层只存在于通信子网以外的主机)</p><h3 id="传输功能"><a href="#传输功能" class="headerlink" title="传输功能"></a>传输功能</h3><ul><li><strong>【应用进程之间的逻辑通信】</strong> 从传输层来看，通信的真正端点不是主机，而是主机中的进程。</li><li><strong>【复用和分用】</strong><ul><li><strong>复用:</strong> 发送方不同的应用进程都可以使用同一个传输层协议传输数据。</li><li><strong>分用:</strong> 接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li></ul></li><li><strong>【差错检测】</strong><ul><li>对收到的报文 (首部和数据部分) 进行差错检测。</li><li>对于 TCP 协议，接收方发现报文段出错，则要求发送方重发该报文段。</li><li>对于 UDP 协议，接收方发现数据报出错，则直接丢弃。</li><li>在网络层，IP 数据报首部中的检验和字段只检验首部是否出错，而不检查数据部分。</li></ul></li><li><strong>【提供面向连接和无连接的】</strong><ul><li>传输层向高层屏蔽了低层网络核心的细节，向两个传输层实体之间提供一条端到端逻辑通信信道。</li><li><strong>TCP:</strong> 尽管下面的网络不可靠 (只提供尽最大努力的交付) 但这种逻辑通信信道就相当于一条全双工的可靠信道。</li><li><strong>UDP:</strong> 这种逻辑通信信道仍是一条不可靠信道。</li></ul></li></ul><h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口让应用层的各种进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。在输出层的作用类似于 IP 在网络层的作用。</p><ul><li><strong>【软件端口】</strong> 协议栈层间抽象的协议端口，是应用层的各种协议进程与传输实体进行层间交互的一种地址，不同于路由器或交换机上的硬件端口。传输层使用的是软件端口。应用进程通过端口号标识。</li><li><strong>【硬件端口】</strong> 不同硬件设备间进行交互的接口。</li></ul><h3 id="服务访问点"><a href="#服务访问点" class="headerlink" title="服务访问点"></a>服务访问点</h3><table><thead><tr><th align="left">层级</th><th align="left">服务访问点名称</th></tr></thead><tbody><tr><td align="left">数据链路层</td><td align="left">帧的类型字段</td></tr><tr><td align="left">网络层</td><td align="left">IP 数据报的协议字段</td></tr><tr><td align="left">传输层</td><td align="left">端口号字段</td></tr><tr><td align="left">应用层</td><td align="left">用户界面</td></tr></tbody></table><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ul><li><strong>长度:</strong> 16bit (2^16&#x3D;65536)</li><li>端口号只具有本地意义 (只标识本地计算机应用层中的进程)</li><li>两类端口号:<ul><li><strong>服务端使用熟知端口号:</strong> 0~1023 IANA 将其指派给 TCP&#x2F;IP 最重要的一些用户程序。</li></ul></li></ul><table><thead><tr><th align="left">应用程序</th><th align="left">FTP</th><th align="left">TELNET</th><th align="left">SMTP</th><th align="left">DNS</th><th align="left">TFTP</th><th align="left">HTTP</th><th align="left">SNMP</th></tr></thead><tbody><tr><td align="left">熟知端口号</td><td align="left">21</td><td align="left">23</td><td align="left">25</td><td align="left">53</td><td align="left">69</td><td align="left">80</td><td align="left">161</td></tr></tbody></table><pre><code>*   **登记端口号:** 1024~49151 供没有熟知端口号的应用程序使用。要使用它们必须在 IANA 登记，以防重复。
*   **用户进程使用的端口号:** 49152~65535 仅在客户进程运行时才动态地选择。又称短暂端口号。通信结束后刚用过的客户端口号就不复存在。
</code></pre><h2 id="无连接服务与面向连接服务-TCP-IP-协议族在-IP-层之上使用的两种传输协议"><a href="#无连接服务与面向连接服务-TCP-IP-协议族在-IP-层之上使用的两种传输协议" class="headerlink" title="无连接服务与面向连接服务 (TCP&#x2F;IP 协议族在 IP 层之上使用的两种传输协议)"></a>无连接服务与面向连接服务 (TCP&#x2F;IP 协议族在 IP 层之上使用的两种传输协议)</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li><strong>【面向连接的传输控制协议】</strong> 面向连接，可靠。</li><li>采用 TCP 时，传输层向上提供一条全双工的可靠逻辑信道。</li><li>主要适用于可靠性更重要的场合。通信双方在传送数据之前必须先建立连接，然后基于此连接进行可靠数据传输。数据传输结束后要释放连接。</li><li>TCP 不提供广播或多播服务。</li><li>为了实现可靠传输，增加了 <strong>【确认】</strong> <strong>【流量控制】</strong> <strong>【计时器】</strong> 及 <strong>【连接管理】</strong> 等。</li><li><strong>适用场合:</strong> <strong>【文件传输协议 FTP】</strong> <strong>【超文本传输协议 HTTP】</strong> <strong>【远程登陆 TELNET】</strong>。</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><strong>【无连接的用户数据报协议】</strong> 无连接，不可靠。</li><li>采用 UDP 时，传输层向上提供的是一条不可靠的逻辑信道。双方传送数据之前不需要建立连接，接收方的传输层在收到 UDP 用户数据报后无须给发送方发回任何确认。</li><li>UDP 在 IP 层之上仅提供两个附加服务: 多路复用和对数据包的错误检查。IP 层知道怎样将分组投递给一台主机，但不知道怎样把它们投递到主机上的具体应用。(TCP&#x2F;IP 协议中的 IP 层对应 OSI 模型中的网络层。)</li><li><strong>适用场合:</strong> <strong>【小文件传送协议 TFTP】</strong> <strong>【DNS】</strong> <strong>【SNMP】</strong> 和 <strong>【实时传输协议 RTP】</strong>。</li></ul><h2 id="典型互联网应用协议"><a href="#典型互联网应用协议" class="headerlink" title="典型互联网应用协议"></a>典型互联网应用协议</h2><p><strong>表5.1 一些典型互联网应用所用的 TCP&#x2F;IP 应用层协议和传输层协议</strong></p><table><thead><tr><th align="left">互联网应用</th><th align="left">TCP&#x2F;IP 应用层协议</th><th align="left">TCP&#x2F;IP 传输层协议</th></tr></thead><tbody><tr><td align="left">域名解析</td><td align="left">域名系统 (DNS)</td><td align="left">UDP</td></tr><tr><td align="left">文件传送</td><td align="left">简单文件传送协议 (TFTP)</td><td align="left">UDP</td></tr><tr><td align="left">路由选择</td><td align="left">路由信息协议 (RIP)</td><td align="left">UDP</td></tr><tr><td align="left">网络参数配置</td><td align="left">动态主机配置协议 (DHCP)</td><td align="left">UDP</td></tr><tr><td align="left">网络管理</td><td align="left">简单网络管理协议 (SNMP)</td><td align="left">UDP</td></tr><tr><td align="left">IP 多播</td><td align="left">网际组管理协议 (IGMP)</td><td align="left">UDP</td></tr><tr><td align="left">电子邮件</td><td align="left">简单邮件传送协议 (SMTP)</td><td align="left">TCP</td></tr><tr><td align="left">远程终端接入</td><td align="left">电传机网络 (TELNET)</td><td align="left">TCP</td></tr><tr><td align="left">万维网</td><td align="left">超文本传送协议 (HTTP)</td><td align="left">TCP</td></tr><tr><td align="left">文件传送</td><td align="left">文件传送协议 (FTP)</td><td align="left">TCP</td></tr></tbody></table><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><strong>IP 数据报和 UDP 数据报:</strong> IP 数据报在网络层要经过路由器的存储转发; UDP 数据包在传输层端到端逻辑信道中传输，封装成 IP 数据报在网络层传输时，UDP 数据报的信息对路由器不可见。</li><li><strong>TCP 和网络层虚电路:</strong> TCP 报文段在传输层抽象的逻辑信道中传输，对路由器不可见。虚电路所经过的交换结点都必须保存虚电路状态信息。在网络层如果采用虚电路方式，则无法提供无连接服务。传输层采用 TCP 不影响网络层提供无连接服务。</li></ul><h2 id="UDP-与-TCP"><a href="#UDP-与-TCP" class="headerlink" title="UDP 与 TCP"></a>UDP 与 TCP</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>(此处原文有一张图片，展示 TCP&#x2F;IP 体系结构，包括应用层、运输层、网际层、网络接口层及其对应的协议栈，以及 UDP 和 TCP 对应用层报文的处理示意图。)</p><h3 id="可靠性对比"><a href="#可靠性对比" class="headerlink" title="可靠性对比"></a>可靠性对比</h3><p><strong>发送方</strong></p><table><thead><tr><th align="left">层级</th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">运输层</td><td align="left">无连接不可靠传输服务</td><td align="left">面向连接可靠传输服务</td></tr><tr><td align="left">网际层</td><td align="left">无连接不可靠传输服务</td><td align="left">无连接不可靠传输服务</td></tr><tr><td align="left">网络接口层</td><td align="left"></td><td align="left"></td></tr></tbody></table><p><strong>接收方</strong></p><table><thead><tr><th align="left">层级</th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">运输层</td><td align="left">无连接不可靠传输服务</td><td align="left">面向连接可靠传输服务</td></tr><tr><td align="left">网际层</td><td align="left">无连接不可靠传输服务</td><td align="left">无连接不可靠传输服务</td></tr><tr><td align="left">网络接口层</td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>UDP 向上层提供无连接不可靠传输服务 (适用于 IP 电话、视频会议等实时应用)</li><li>TCP 向上层提供面向连接的可靠传输服务 (适用于要求可靠传输的应用，例如文件传输)</li></ul><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>(此处原文有一张图片，展示 UDP 用户数据报和 TCP 报文段的首部格式。)</p><p><strong>UDP 用户数据报首部</strong></p><table><thead><tr><th align="left">字段名称</th><th align="left">字节数</th><th align="left">比特数</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">目的端口</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">长度</td><td align="left">2</td><td align="left"></td></tr><tr><td align="left">检验和</td><td align="left">2</td><td align="left"></td></tr></tbody></table><ul><li>UDP 用户数据报首部仅 8 字节。</li></ul><p><strong>TCP 报文段首部</strong></p><table><thead><tr><th align="left">字段名称</th><th align="left">比特数</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">16</td></tr><tr><td align="left">目的端口</td><td align="left">16</td></tr><tr><td align="left">序号</td><td align="left">32</td></tr><tr><td align="left">确认号</td><td align="left">32</td></tr><tr><td align="left">数据偏移</td><td align="left">4</td></tr><tr><td align="left">保留</td><td align="left">6</td></tr><tr><td align="left">标志位</td><td align="left">6</td></tr><tr><td align="left">窗口</td><td align="left">16</td></tr><tr><td align="left">检验和</td><td align="left">16</td></tr><tr><td align="left">紧急指针</td><td align="left">16</td></tr><tr><td align="left">选项</td><td align="left">可变</td></tr><tr><td align="left">填充</td><td align="left">可变</td></tr></tbody></table><ul><li>TCP 报文段首部最小 20 字节，最大 60 字节。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">特性</th><th align="left">UDP (User Datagram Protocol)</th><th align="left">TCP (Transmission Control Protocol)</th></tr></thead><tbody><tr><td align="left">连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">端点通信</td><td align="left">支持“一对一”、“一对多”、“多对一”和“多对多”交互通信</td><td align="left">每一条 TCP 连接只能有两个端点 EP，只能是一对一通信</td></tr><tr><td align="left">数据流类型</td><td align="left">面向应用报文</td><td align="left">面向字节流</td></tr><tr><td align="left">可靠性</td><td align="left">尽最大努力交付，即不可靠；不使用流量控制和拥塞控制</td><td align="left">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅 8 字节</td><td align="left">首部开销最小 20 字节，最大 60 字节</td></tr></tbody></table><h2 id="习题查漏补缺"><a href="#习题查漏补缺" class="headerlink" title="习题查漏补缺"></a>习题查漏补缺</h2><ol><li><strong>通信子网、传输层、资源子网</strong><ul><li><strong>通信子网:</strong> 包括物理层、数据链路层和网络层，主要负责数据通信。</li><li><strong>传输层:</strong> 主要任务是向高层用户屏蔽下面通信子网的细节 (如网络拓扑、路由协议等)。</li><li><strong>资源子网:</strong> OSI 参考模型的上三层。</li></ul></li><li>传输层面向连接服务的特性: 保证可靠和顺序交付。</li><li>一个 TCP 报文的首部长度是 20B, 一个 IP 数据报的首部长度也是 20B, 再加上 60B 的数据, 一个 IP 数据报的总长度为 100B, 从而数据占 60%。</li><li>若用户应用程序使用 UDP 进行数据传输, 则必须在传输层的上层即应用层提供可靠性方面的全部工作。</li></ol><h2 id="5-2-UDP-协议"><a href="#5-2-UDP-协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>UDP 仅在 IP 层的数据包服务之上增加了两个最基本的功能，复用和分用，以及差错检测。</p><h3 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h3><ul><li><strong>无需建立连接:</strong> UDP 不会引入建立连接的时延。DNS 运行在 UDP 上，HTTP 运行在 TCP 上。</li><li><strong>无连接状态:</strong><ul><li>TCP 需要在端系统中维护连接状态，此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。</li><li>UDP 既不维护连接状态，也不跟踪这些参数。</li></ul></li><li><strong>UDP 首部开销小:</strong> TCP 首部开销 20B，UDP 首部开销 8B。</li><li><strong>UDP 没有拥塞控制:</strong> 因此网络中的拥塞不会影响源主机的发送速率。</li><li><strong>交互通信:</strong> 支持一对一、一对多、多对一和多对多的交互通信。</li><li><strong>面向报文:</strong><ul><li>发送方 UDP 对应用层交下来的报文，在添加首部后就向下交付给 IP 层，一次发送一个报文，既不合并也不拆分，而是保留这些报文的边界。</li><li>报文不可分割，是 UDP 数据包处理的最小单位。所以应用程序必须选择合适大小的报文。</li></ul></li></ul><h3 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h3><p>(此处原文有一张图片，展示 UDP 数据报格式，包括源端口号、目的端口号、长度、检验和等字段。)<br>UDP 首部一共 8B，有四个字段组成，每个字段的长度都是 2B。</p><ul><li><strong>源端口:</strong> 在需要对方回信时选用。不需要时全 0。</li><li><strong>目的端口:</strong> 必须用到。<ul><li>如果接收方 UDP 发现收到的报文中目的端口号不正确 (不存在对应于端口号的应用进程)，就丢弃该报文，并由 ICMP 发送 “端口不可达” 差错报文给发送方。</li></ul></li><li><strong>长度:</strong> UDP 数据报的长度 (包括首部和数据)，最小值为 8 (仅有首部的情况)。</li><li><strong>检验和:</strong> 检验 UDP 数据报在传输中是否出错，有错就丢弃。可选。如果源主机不想计算检验和，就直接令该字段全 0。</li></ul><h3 id="UDP-检验"><a href="#UDP-检验" class="headerlink" title="UDP 检验"></a>UDP 检验</h3><p>在计算检验和时需要在 UDP 数据报之前增加 12B 的伪首部，得到一个临时的 UDP 数据报。<br>(此处原文有一张图片，展示 UDP 检验和计算时的伪首部结构，以及伪首部、UDP 首部和数据部分的组合示意图。)</p><ul><li>IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和要将首部和数据部分一起检验。</li></ul><h2 id="5-3-TCP-协议"><a href="#5-3-TCP-协议" class="headerlink" title="5.3 TCP 协议"></a>5.3 TCP 协议</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>TCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议，主要解决传输的可靠、有序、无丢失和不重复问题。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>面向连接:</strong> TCP 连接是一条逻辑连接。</li><li><strong>只能一对一:</strong> 每一条 TCP 连接只能有两个端点; 每条 TCP 连接只能是一对一的。</li><li><strong>可靠交付:</strong> 保证传送的数据无差错、不丢失、无重复且有序。</li><li><strong>全双工:</strong> 提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此，TCP 连接的两段都设有发送缓存和接收缓存。<ul><li><strong>发送缓存:</strong> 存放发送应用程序传送给发送方 TCP 准备发送的数据; 存放 TCP 已发送但尚未收到确认的数据。</li><li><strong>接收缓存:</strong> 存放按序到达但尚未被接收应用程序读取的数据; 不按序到达的数据。</li></ul></li><li><strong>面向字节流:</strong> 应用程序和 TCP 的交互是一次一个数据块 (大小不等)，但 TCP 把应用程序交下来的数据仅视为一连串的无结构字节流。<ul><li>UDP 报文的长度由发送应用进程决定。TCP 报文的长度根据接收方给出的窗口值和当前网络拥塞程度来决定。</li></ul></li></ul><h3 id="TCP-报文段-TCP-传送的数据单元。既可以运载数据，又可以建立连接、释放连接和应答"><a href="#TCP-报文段-TCP-传送的数据单元。既可以运载数据，又可以建立连接、释放连接和应答" class="headerlink" title="TCP 报文段 (TCP 传送的数据单元。既可以运载数据，又可以建立连接、释放连接和应答)"></a>TCP 报文段 (TCP 传送的数据单元。既可以运载数据，又可以建立连接、释放连接和应答)</h3><h3 id="首部格式-1"><a href="#首部格式-1" class="headerlink" title="首部格式"></a>首部格式</h3><p>(此处原文有一张图片，展示 TCP 报文段的首部格式，包括固定首部和扩展首部中的各个字段。)</p><ul><li><strong>序号:</strong> 占 32bit, 取值范围为 0~(2^32)-1。用来指出本 TCP 报文段数据载荷的第一个字节的序号。当序号增加到最后一个时下一个序号又回到 0。</li><li><strong>确认号:</strong> 占 32bit, 取值范围为 0~(2^32)-1。用来指出期望收到对方下一个 TCP 报文段的数据载荷的第一个字节的序号。同时也是对之前收到的所有数据的确认。当确认号增加到最后一个时下一个确认号又回到 0。</li><li><strong>确认标志位 ACK:</strong> 只有当 ACK 取值为 1 时，确认号字段才有效，否则无效。TCP 规定在 TCP 连接建立后，所有传送的 TCP 报文段都必须把 ACK 置 1。</li><li><strong>数据偏移:</strong> 占 4bit, 该字段的取值以 4 字节为单位，指出 TCP 报文段的数据载荷部分的起始处距离 TCP 报文段的起始处有多远。这实际上指出 TCP 报文段的首部长度。<ul><li>在 TCP 协议中，数据偏移 (Data Offset) 字段是 TCP 头部的一个组成部分，用于指示 TCP 头部的长度。这个字段占用 4 位 (bit)，因此它可以取值的范围是 0 到 15 (因为 2^4&#x3D;16)，这表示 TCP 头部长度可以从 0 到 60 字节 (因为每个值代表 4 字节，所以 15 乘以 4 等于 60)。</li><li>(此处原文有一张图片，展示数据偏移字段在 TCP 报文段中的位置示意图。)</li></ul></li><li><strong>保留字段:</strong> 占 6bit, 目前应置为 0。</li><li><strong>窗口字段:</strong><ul><li>占 16 比特，该字段的取值以字节为单位。</li><li>指出发送本报文段的一方的接收窗口的大小，即接收缓存的可用空间大小，这用来表征接收方的接收能力。</li><li>在计算机网络中，经常用接收方的接收能力的大小来控制发送方的数据发送量，这就是所谓的流量控制。</li></ul></li><li><strong>检验和字段:</strong> 占 16bit, 用来检查整个 TCP 报文段在传输过程中是否出现了误码。</li><li><strong>同步标志位 SYN:</strong> 用于 TCP “三报文握手” 建立连接。当 SYN&#x3D;1 且 ACK&#x3D;0 时表明这是一个 TCP 连接请求报文段。对方若同意建立连接则应在响应的 TCP 报文段的首部中使 SYN&#x3D;1 且 ACK&#x3D;1。所以 SYN 为 1 的 TCP 报文段要么是一个连接请求报文段，要么是一个连接响应报文段。</li><li><strong>终止标志位 FIN:</strong> 用于 TCP “四报文挥手” 释放连接。FIN&#x3D;1 时表明此 TCP 报文段的发送方已经将全部数据发送完毕，现在要求释放 TCP 连接。</li><li><strong>复位标志位 RST:</strong> 用于复位 TCP 连接。当 RST&#x3D;1 时表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接。RST 置 1 还用来拒绝一个非法的 TCP 报文段或拒绝打开一个 TCP 连接。</li><li><strong>推送标志位 PSH:</strong><ul><li>出于效率的考虑，TCP 的发送方可能会延迟发送数据，而 TCP 的接收方可能会延迟向应用进程交付数据。这样可以一次处理更多的数据。</li><li>但是当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应，在这种情况下，应用进程可以通知 TCP 使用推送 (PUSH) 操作。</li><li>发送方 TCP 把 PSH 置 1，并立即创建一个 TCP 报文段发送出去，而不需要积累到足够多的数据再发送。</li><li>接收方 TCP 收到 PSH 为 1 的 TCP 报文段，就尽快地交付给应用进程，而不再等到接收到足够多的数据才向上交付。</li></ul></li><li><strong>紧急标志位 URG:</strong> 1 表示紧急指针字段有效。0 表示无效。</li><li><strong>紧急指针:</strong><ul><li>占 16 比特，以字节为单位，用来指明紧急数据的长度。</li><li>当发送方有紧急数据时，可将紧急数据 “插队” 到发送缓存的最前面，并立刻封装到一个 TCP 报文段中进行发送，紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>接收方收到紧急标志位为 1 的 TCP 报文段，会按照紧急指针字段的值从报文段数据载荷中取出紧急数据并直接上交应用进程，而不必在接收缓存中排队。</li></ul></li></ul><h3 id="计算检验和"><a href="#计算检验和" class="headerlink" title="计算检验和"></a>计算检验和</h3><p>(此处原文有一张图片，展示了 TCP 报文段首部格式，以及发送方和接收方计算检验和的方法，并与 UDP 检验和进行比较。)</p><ul><li><strong>发送方检验和计算方法:</strong><ol><li>将 TCP 首部中检验和字段的值置为 0。</li><li>将伪首部、TCP 首部以及数据载荷这三部分划分成若干个 2 字节的字。若伪首部、TCP 首部以及数据载荷这三部分的总长度不是偶数个字节，则在最后添加 1 个 “全 0” 字节。</li><li>对划分出的全部 2 字节的字进行反码算数运算求和，并将求和结果取反码。</li><li>将步骤 3 得到的结果写入 TCP 首部中的检验和字段。</li></ol><ul><li>与 IPv4 数据报首部检验和的计算方法 (4.2.7 节) 类似，差别仅在于前者只对首部进行检验。</li></ul></li><li><strong>接收方通过检验和字段的值判断 TCP 报文段在传输过程中是否误码的方法:</strong><ol><li>给接收到的 TCP 报文段前面添加一个 12 字节的伪首部。</li><li>将伪首部、TCP 首部以及数据载荷这三部分划分成若干个 2 字节的字。</li><li>对划分出的全部 2 字节的字进行反码算数运算求和，并将求和结果取反码。</li><li>若步骤 3 得到的结果为 0，则表示 TCP 报文段在传输过程中没有误码。否则，表示出现了误码。</li></ol></li><li><strong>与 UDP 进行比较:</strong><ul><li>(此处原文有一张图片，展示 UDP 和 TCP 检验和的异同点。)</li></ul></li></ul><h3 id="TCP-运输连接"><a href="#TCP-运输连接" class="headerlink" title="TCP 运输连接"></a>TCP 运输连接</h3><p>分为三个阶段:</p><ol><li>通过 “三报文握手” 来建立 TCP 连接。</li><li>基于已建立的 TCP 连接进行可靠的数据传输。</li><li>在数据传输结束后还要通过 “四报文挥手” 来释放 TCP 连接。</li></ol><h4 id="“三报文握手”-建立-TCP-连接"><a href="#“三报文握手”-建立-TCP-连接" class="headerlink" title="“三报文握手” 建立 TCP 连接"></a>“三报文握手” 建立 TCP 连接</h4><p><strong>目的:</strong> 在于解决以下三个主要问题:</p><ul><li>使 TCP 双方能够确知对方的存在。</li><li>使 TCP 双方能够协商一些参数 (最大报文段长度、最大窗口大小、时间戳选项等)。</li><li>使 TCP 双方能够对运输实体资源进行分配和初始化，运输实体资源包括缓存大小、各状态变量、连接表中的项目等。</li></ul><ol><li>每条 TCP 连接有两个端点，此端点即套接字。每条 TCP 连接唯一地被通信的两个端点 (套接字) 确定。</li><li>同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。</li><li>TCP 连接的建立采用客户&#x2F;服务器模式，主动发起连接建立的应用进程称为客户，而被动等待连接建立的应用进程称为服务器。</li></ol><p><strong>过程:</strong><br>(此处原文有三张图片，逐步展示了 TCP 建立连接的 “三报文握手” 过程，包括 SYN 包、SYN-ACK 包、ACK 包的发送和状态转换。)</p><ul><li><strong>序号 seq 字段被设置了一个初始值 x，作为 TCP 客户进程所选择的初始序号。</strong></li><li><strong>请同学们注意:</strong><ul><li>TCP 规定同步标志位 SYN 被设置为 1 的报文段 (例如 TCP 连接请求报文段和 TCP 连接请求确认报文段) 不能携带数据，但要消耗掉一个序号。</li><li>按上述规定，TCP 连接请求报文段不能携带数据 (即没有数据载荷)，但是会消耗掉序号 x。</li><li>因此，TCP 客户进程下一次发送的 TCP 报文段的数据载荷的第一个字节的序号为 x+1。</li></ul></li><li><strong>补充:</strong> 上述过程发送的第三个普通的 TCP 报文段是否多余?(使用三报文握手而不是两报文握手建立 TCP 连接的原因)<ul><li><strong>“三报文握手”建立 TCP 连接 ————使用“三报文握手”而不是“两报文握手”建立 TCP 连接的原因</strong><br>(此处原文有一张图片，展示了使用两报文握手可能导致已失效的连接请求报文段被接受，从而造成资源浪费的场景。)</li><li>采用 “三报文握手” 而不是 “两报文握手” 来建立 TCP 连接，是为了防止已失效的 TCP 连接请求报文段突然又传送到了 TCP 服务器进程，因而导致错误。</li></ul></li></ul><h4 id="“四报文挥手”-释放-TCP-连接"><a href="#“四报文挥手”-释放-TCP-连接" class="headerlink" title="“四报文挥手” 释放 TCP 连接"></a>“四报文挥手” 释放 TCP 连接</h4><p><strong>第一步:</strong> 客户机发送连接释放报文段，并停止发送数据，主动关闭 TCP 连接。该报文段终止位 FIN 设置为 1，序号 seq&#x3D;u (等于前面已传送过的数据的最后一个字节的序号加 1)。<br>(此处原文有一张图片，展示了 TCP 释放连接的第一步，客户机发送 FIN 包，进入 FIN-WAIT-1 状态。)</p><ul><li>TCP 连接释放报文段首部中的终止标志位 FIN 和确认标志位 ACK 的值都被设置为 1。</li><li>表明这是一个 TCP 连接释放报文段，同时也对之前收到的 TCP 报文段进行确认。</li></ul><p><strong>第二步:</strong> 服务器收到连接释放报文段后发出确认。<br>(此处原文有一张图片，展示了 TCP 释放连接的第二步，服务器收到 FIN 包后发送 ACK 包，进入 CLOSE-WAIT 状态。)</p><ul><li>TCP 规定终止标志位 FIN 等于 1 的 TCP 报文段即使不携带数据，也要消耗掉一个序号。</li><li>从 TCP 客户进程到 TCP 服务器进程这个方向的连接就释放了。</li><li><strong>此时的 TCP 连接属于半关闭状态。</strong><ul><li>TCP 客户进程已经没有数据要发送了。但 TCP 服务器进程如果还有数据要发送，TCP 客户进程仍要接收，也就是从 TCP 服务器进程到 TCP 客户进程这个方向的连接并未关闭。</li><li>半关闭状态可能会持续一段时间。</li></ul></li></ul><p><strong>第三步:</strong> 若服务器已经没有要向客户机发送的数据，就通知 TCP 释放连接。<br>(此处原文有一张图片，展示了 TCP 释放连接的第三步，服务器发送 FIN 包，进入 LAST-ACK 状态。)</p><ul><li>TCP 连接释放报文段首部中的终止标志位 FIN 和确认标志位 ACK 的值都被设置为 1。</li><li>表明这是一个 TCP 连接释放报文段，同时也对之前收到的 TCP 报文段进行确认。</li></ul><p><strong>第四步:</strong><br>(此处原文有一张图片，展示了 TCP 释放连接的第四步，客户机发送 ACK 包，进入 TIME-WAIT 状态，服务器进入 CLOSED 状态。)</p><ul><li><strong>TIME-WAIT (时间等待) 状态</strong><ul><li>MSL 是最长报文段寿命 (Maximum Segment Lifetime) 的英文缩写词，[RFC793] 建议为 2 分钟。也就是说，TCP 客户进程进入时间等待 (TIME-WAIT) 状态后，还要经过 4 分钟才能进入关闭 (CLOSED) 状态。</li></ul></li><li><strong>补充:</strong> 为何要经过 2MSL 后才进入关闭状态?<ul><li>处于时间等待 (TIME-WAIT) 状态后要经过 2MSL 时长，可以确保 TCP 服务器进程能够收到最后一个 TCP 确认报文段而进入关闭 (CLOSED) 状态。</li><li>另外，TCP 客户进程在发送完最后一个 TCP 确认报文段后，再经过 2MSL 时长，就可以使本次连接持续期内所产生的所有报文段都从网络中消失。这样就可以使下一个新的 TCP 连接中不会出现旧连接中的报文段。</li></ul></li></ul><p><strong>总结:</strong></p><table><thead><tr><th align="left">阶段</th><th align="left">建立连接</th><th align="left">释放连接</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SYN&#x3D;1 seq&#x3D;x</td><td align="left">FIN&#x3D;1 seq&#x3D;u</td></tr><tr><td align="left">2</td><td align="left">SYN&#x3D;1 ACK&#x3D;1 seq&#x3D;y ack&#x3D;x+1</td><td align="left">ACK&#x3D;1 seq&#x3D;v ack&#x3D;u+1</td></tr><tr><td align="left">3</td><td align="left">ACK&#x3D;1 seq&#x3D;x+1 ack&#x3D;y+1</td><td align="left">FIN&#x3D;1 ACK&#x3D;1 seq&#x3D;w ack&#x3D;u+1</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">ACK&#x3D;1 seq&#x3D;u+1 ack&#x3D;w+1</td></tr></tbody></table><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>TCP 在不可靠的 IP 层之上建立一种可靠数据传输服务，该服务保证接收方从缓存区读出的字节流与发送方发出的字节流完全一样。TCP 使用了检验、序号、确认和重传等机制来达到这一目的。</p><h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>TCP 将数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。下图中第二个报文段的序号是 3。<br>(此处原文有一张图片，展示了 TCP 报文段中字节流的序号划分。)</p><h4 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h4><p>确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>TCP 默认使用 <strong>【累积确认】</strong>, 即 TCP 只确认数据流中至第一个丢失字节为止的字节。</p><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><p>超时和冗余 ACK 会导致 TCP 对报文段进行重传。</p><h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p>TCP 每发送一个报文段就对这个报文段设置一个超时计时器。计时器设置的重传时间到但还未收到确认时，就要重传这一报文段。<br>TCP 采用一种自适应算法来计算超时计时器的重传时间。一个报文段发出的时间以及收到相应确认的时间的间隔称为报文段的往返时间 RTT。TCP 维护 RTT 的一个加权平均往返时间 RTTS，<strong>【超时重传时间】</strong> 应该略大于 RTTS。</p><h5 id="冗余-ACK-冗余确认"><a href="#冗余-ACK-冗余确认" class="headerlink" title="冗余 ACK (冗余确认)"></a>冗余 ACK (冗余确认)</h5><p>冗余 ACK 就是再次确认某个报文段的 ACK。<br>TCP 规定每当比期望序号大的失序报文段到达时，就发送一个冗余 ACK，指明下一个期待字节的序号。<br>例如 3,4,5 号报文段到达时不是自己所期望的 2 号报文段，那就发送 3 个对 1 号报文段的 ACK。</p><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>TCP 为应用程序提供了流量控制机制，以解决因发送方发送数据太快而导致接收方来不及接收，造成接收方的接收缓存溢出的问题。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><strong>基本方法:</strong> 接收方根据自己的接收能力 (接收缓存的可用空间大小) 控制发送方的发送速率。</li><li><strong>采用滑动窗口机制。</strong> TCP 要求发送方维持一个接收窗口 rwnd，接收方根据当前接受缓存的大小动态地调整接收窗口的大小，这个值被放在接收方 TCP 报文段首部中的窗口字段，以通知发送方。发送方的发送窗口不能超过接收方给出的接收窗口值，以限制发送方向网络注入报文的速率。</li><li><strong>TCP 为每个连接设有一个【持续计时器】</strong>，只要发送方收到对方的零窗口通知就启动持续计时器。如果计时器超时，就发送一个零窗口探测报文段，对方就在确认这个探测报文段时给出现在的窗口值。如果窗口仍然为 0，则发送方收到确认报文段后就重新设置持续计时器。<br>(此处原文有一张图片，展示了 TCP 流量控制方法，包括零窗口探测报文段的发送和确认过程。)<ul><li>实际上 TCP 规定: 即使接收窗口值为 0，也必须接受零窗口探测报文段、确认报文段以及携带有紧急数据的报文段。</li><li>回答是肯定的。因为零窗口探测报文段也有重传计时器，当重传计时器超时后，零窗口探测报文段会被重传。</li></ul></li></ul><h4 id="流量控制与数据链路层流量控制比较"><a href="#流量控制与数据链路层流量控制比较" class="headerlink" title="流量控制与数据链路层流量控制比较"></a>流量控制与数据链路层流量控制比较</h4><table><thead><tr><th align="left">特性</th><th align="left">传输层</th><th align="left">数据链路层</th></tr></thead><tbody><tr><td align="left">控制范围</td><td align="left">端到端 (两个进程之间流量控制)</td><td align="left">两个中间的相邻结点之间的流量控制</td></tr><tr><td align="left">窗口大小</td><td align="left">窗口大小可动态变化</td><td align="left">窗口大小不能动态变化</td></tr></tbody></table><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h4 id="拥塞控制和流量控制"><a href="#拥塞控制和流量控制" class="headerlink" title="拥塞控制和流量控制"></a>拥塞控制和流量控制</h4><ul><li><strong>拥塞控制:</strong> 指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。</li><li><strong>拥塞出现时，端点并不了解拥塞发生的细节，但是对于通信的端点来说，拥塞往往表现为通信时延的增加。</strong></li><li><strong>TCP 的四种拥塞算法:</strong> 慢开始、拥塞避免、快重传和快恢复。</li></ul><h4 id="闭环拥塞控制算法分类"><a href="#闭环拥塞控制算法分类" class="headerlink" title="闭环拥塞控制算法分类"></a>闭环拥塞控制算法分类</h4><p>根据拥塞信息的反馈形式，可将闭环拥塞控制算法分为：</p><ul><li><strong>显式反馈算法:</strong> 从拥塞节点 (即路由器) 向源点提供关于网络中拥塞状态的显式反馈信息。</li><li><strong>隐式反馈算法:</strong> 源点自身通过对网络行为的观察 (例如超时重传或往返时间 RTT) 来推断网络是否发生拥塞。TCP 采用的就是隐式反馈算法。<br>(此处原文有一张图片，展示隐式反馈和显式反馈算法的区别。)<ul><li>拥塞控制并不仅仅是运输层要考虑的问题。显式反馈算法就必须涉及网络层。虽然一些网络体系结构 (如 ATM 网络) 主要在网络层实现拥塞控制，但因特网主要利用隐式反馈在运输层实现拥塞控制。</li></ul></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><strong>流量控制:</strong> 通常指点对点的通信量控制，要做的是抑制发送端发送数据的速率，以便接收端来得及接收。</li><li><strong>拥塞控制:</strong> 让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li></ul><h4 id="拥塞窗口-cwnd"><a href="#拥塞窗口-cwnd" class="headerlink" title="拥塞窗口 (cwnd)"></a>拥塞窗口 (cwnd)</h4><p>TCP 除了上文的接收窗口，还要求发送方维持一个拥塞窗口，其大小取决于网络的拥塞程度，动态变化。<br>发送方控制拥塞窗口的原则: 只要网络出现拥塞，拥塞窗口就减小一些。<br>发送窗口的上限值取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</p><ul><li>发送窗口上限值 &#x3D; min{rwnd, cwnd}</li></ul><h4 id="慢开始和拥塞避免-拥塞避免并不能完全避免拥塞，只是使得网络不容易出现拥塞"><a href="#慢开始和拥塞避免-拥塞避免并不能完全避免拥塞，只是使得网络不容易出现拥塞" class="headerlink" title="慢开始和拥塞避免 (拥塞避免并不能完全避免拥塞，只是使得网络不容易出现拥塞)"></a>慢开始和拥塞避免 (拥塞避免并不能完全避免拥塞，只是使得网络不容易出现拥塞)</h4><h5 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h5><ul><li><strong>具体方法:</strong> 先发送少量数据探测一下，若没有发生拥塞则适当增大拥塞窗口。(从小到大逐渐增大拥塞窗口 (发送窗口))</li><li><strong>慢开始门限 (ssthresh):</strong> 每经过一个传输轮次 (RTT)，cwnd 就会加倍。cwnd 随轮次指数增长。</li><li>慢开始一直把 cwnd 增大到一个规定的 ssthresh，然后改用拥塞避免算法。</li></ul><h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><ul><li><strong>具体方法:</strong> 每经过一个往返时延 RTT 就把发送方拥塞窗口 cwnd 加 1，而不是翻倍。</li><li><strong>过程:</strong><ul><li>cwnd &lt; ssthresh, 使用慢开始。</li><li>cwnd &gt; ssthresh, 改用拥塞避免算法。</li><li>cwnd &#x3D; ssthresh, 通常使用拥塞避免算法，也可以使用慢开始。</li></ul></li></ul><h4 id="网络拥塞处理"><a href="#网络拥塞处理" class="headerlink" title="网络拥塞处理"></a>网络拥塞处理</h4><p>无论在何阶段，只要发送方判断网络出现拥塞，就首先把慢开始门限 ssthresh 设置为出现拥塞时发送方 cwnd 值的一般 (不能小于 2)，然后把 cwnd 重新设置为 1，继而执行慢开始算法。<br><strong>注意:</strong> 慢开始阶段，如果 2<em>cwnd &gt; ssthresh，则下一个 RTT 后 cwnd 等于 ssthresh，而非 2</em>cwnd。</p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><h5 id="快重传概述"><a href="#快重传概述" class="headerlink" title="快重传概述"></a>快重传概述</h5><p>个别报文段在网络中丢失，但是此时网络其实并未发生拥塞，但发送方收不到确认就会误认为网络发生了拥塞，从而启动慢开始算法降低传输效率。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>使发送方尽早尽快地进行重传，不等计时器超时再重传。接收方即使受到了失序的报文段也要立即发出对已收到的报文段的重复确认。发送方一旦连续收到 3 个冗余 ACK (重复确认)，就立即重传相应的报文段。</p><h5 id="快恢复原理"><a href="#快恢复原理" class="headerlink" title="快恢复原理"></a>快恢复原理</h5><p>当发送方收到 3 个冗余 ACK (重复确认) 时，执行 “乘法减小”，把慢开始门限 ssthresh 调整为当前 cwnd 的一半。发送方此时认为网络很可能没有发生拥塞。并把 cwnd 值夜调整为当前 cwnd 的一半，此时 cwnd 等于 ssthresh，然后开始执行拥塞避免算法。<br>(此处原文有一张图片，展示了 TCP 拥塞控制的慢开始、拥塞避免、快重传和快恢复四种算法的结合图。)</p><h4 id="TCP-拥塞控制机制中四种算法的同时应用"><a href="#TCP-拥塞控制机制中四种算法的同时应用" class="headerlink" title="TCP 拥塞控制机制中四种算法的同时应用"></a>TCP 拥塞控制机制中四种算法的同时应用</h4><p>TCP 连接建立和网络出现超时时，采用慢开始和拥塞避免算法 (ssthresh&#x3D;cwnd&#x2F;2, cwnd&#x3D;1)。<br>发送方收到 3 个冗余 ACK 时，采用快重传和快恢复算法 (ssthresh&#x3D;cwnd&#x2F;2, cwnd&#x3D;ssthresh)。</p><h3 id="习题查漏补缺-1"><a href="#习题查漏补缺-1" class="headerlink" title="习题查漏补缺"></a>习题查漏补缺</h3><ol><li>在 TCP 首部中没有目标主机 IP 地址。</li><li>TCP 报文段和 UDP 报文段都包含源端口、目的端口、检验号。因为 UDP 提供不可靠的传输服务，所以不需要对报文进行编号，不会有序列号字段。相比之下，TCP 需要有序列号字段。</li><li>TCP 的滑动窗口协议中规定重传分组的数量最多可以是滑动窗口的大小。</li><li>假设 TCP 客户与 TCP 服务器的通信已结束，端到端的往返时间为 RTT。t 时刻 TCP 客户请求断开连接，则从 t 时刻起 TCP 服务器释放该连接的最短时间是 <strong>1.5 个 RTT</strong>。<ul><li><strong>1.5 个 RTT</strong>。t 时刻 TCP 客户请求断开连接，发出连接释放 FIN 报文段。当 TCP 服务器收到 TCP 客户发来的 FIN 报文段后不能再发送数据，因此同时发出确认 ACK 报文段和连接释放 FIN 报文段，即直接跳过 CLOSED-WAIT 状态。TCP 客户收到 FIN 报文段后必须发出确认，TCP 服务器收到确认后就进入 CLOSED 状态，共经历 1.5 个 RTT。</li></ul></li><li>TCP 采用对 <strong>【报文段】</strong> 的确认机制。</li><li>TCP 中滑动窗口的值设置得太大，对主机的影响是 <strong>【由于传送的数据过多而使路由器变得拥挤，主机可能丢失分组】</strong>。</li></ol></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://polarwanderer.cn/2025/06/22/0218/" data-id="cmc6kv5re001vqszb6btagxp0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwklEQVR42u3aQY7DIBAEQP//094HRNg9gyHOqjhZiQWVHFoww3HE4xyMz29H74/mPFYMXFzcae55OarLXyPy+Yez4eLibuReB83nO/lPGi18Pf/wc1xc3Fdye5GXbIlwcXH/Bzf/JAlBXFzct3GTeMop8/H3wFkNFxd3gptXKdc9L6nv4uLitrhncfSi6rqkUlgdFxd3CzcPlGp7tRqIybq4uLjf5eYFi2r7JC/HFJqsuLi4j3J7y1RjLm+13vwRuLi4G7l5rFRLJ3kBNApTXFzc7dweMd+45AWRoQQXF3cLNyltzGxcEkrzrIaLi7udW70slV+Y6G19boIMFxd3AbdX2qheusqzKGrP4OLiLuP2mihVerV0Ujir4eLiLuCumKi6iWle0cDFxV3MnQmv/P28ZXJTdsHFxd3I7ZU+55/zwxUuLu4buNVWRx5tM21aXFzc1dyzOOYPP3kBBRcX91vc6nWr6gJ5qD18RQwXF3eam4dOXtpI/pteyxYXF3cnNw+a/MLWwrMaLi7uy7gzx6fqEQsXF/cXudXWbB5nw/lxcXE3cnvFzWozdf5AhYuLu4dbjZJk4aQgku9bcHFxN3L/APf1uWiSHLjCAAAAAElFTkSuQmCC">Share</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94/" rel="tag">计算机考研</a></li></ul></div><div class="post-nav"><a class="next" href="/2025/03/25/1558/">【数据结构】第二章-线性表</a></div><div class="nofancybox" id="waline"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/@waline/client@v3/dist/waline.css"><script type="module">import{init}from"https://unpkg.com/@waline/client@v3/dist/waline.js";init({el:"#waline",comment:!0,serverURL:"comments.polarwanderer.cn",pageSize:"8",wordLimit:"120",requiredMeta:requiredMeta,emoji:["//unpkg.com/@waline/emojis@1.2.0/weibo","//unpkg.com/@waline/emojis@1.2.0/qq","//unpkg.com/@waline/emojis@1.2.0/tw-emoji"]})</script><script>let metaInfo=["nick","mail","link"],requiredMeta="nick,mail".split(",").filter(i=>metaInfo.indexOf(i)>-1)</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0" readonly></div></div><div class="search-modal" id="search-modal"><div class="search-modal-content"><div class="search-modal-header"><input class="search-modal-input" id="modal-search-input" placeholder="输入关键词搜索..." type="text" name="q"></div><div class="search-modal-body"><div id="modal-search-result"></div></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o">Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o">Tags</i></div><div class="tagcloud"><a href="/tags/408/" style="font-size:15px">408</a> <a href="/tags/%E4%BA%BA%E7%89%A9/" style="font-size:15px">人物</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:15px">历史</a> <a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size:15px">哲学</a> <a href="/tags/%E5%9B%9E%E5%BF%86/" style="font-size:15px">回忆</a> <a href="/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" style="font-size:15px">年终总结</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size:15px">思考</a> <a href="/tags/%E6%84%9F%E6%82%9F/" style="font-size:15px">感悟</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:15px">数学建模</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:15px">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:15px">机器学习</a> <a href="/tags/%E6%A2%A6%E5%A2%83/" style="font-size:15px">梦境</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:15px">生活</a> <a href="/tags/%E7%A4%BE%E4%BC%9A%E7%8E%B0%E8%B1%A1/" style="font-size:15px">社会现象</a> <a href="/tags/%E7%AB%9E%E8%B5%9B/" style="font-size:15px">竞赛</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size:15px">笔记</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size:15px">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size:15px">网络层</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:15px">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94/" style="font-size:15px">计算机考研</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size:15px">记录</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:15px">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o">Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/22/0218/">[计算机网络]第五章-传输层</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/1558/">【数据结构】第二章-线性表</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/1556/">【数据结构】第一章-基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/24/2121/">【计算机网络】第四章-网络层(上)</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/29/0021/">浪迹天涯</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/08/2317/">寻书</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/25/2338/">半年志</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/02/07/2150/">2024年美赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/31/2342/">抓住2023的小尾巴</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/12/1620/">11月12日</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o">Recent Comments</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverurl="comments.polarwanderer.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022-2025 <a href="/." rel="nofollow">BlankChen.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;searchFunc(path,"local-search-input","local-search-result")</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/js/sticky-header.js?v=1.0.0"></script><script type="text/javascript" src="/js/toc-generator.js?v=1.0.0"></script><script type="text/javascript" src="/js/snowfall.js?v=1.0.0"></script><script type="text/javascript" src="/js/text-reader.js?v=1.0.0"></script><script type="text/javascript" src="/js/floating-buttons.js?v=1.0.0"></script><script type="text/javascript" src="/js/random-post.js?v=1.0.0"></script><script type="text/javascript" src="/js/thoughts-typewriter.js?v=1.0.0"></script><script type="text/javascript" src="/js/subtitle-typewriter.js?v=1.0.0"></script></div></body></html>