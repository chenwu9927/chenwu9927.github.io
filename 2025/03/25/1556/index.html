<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>数据结构 | Polarwanderer</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="preconnect" href="https://fonts.loli.net" crossorigin><link rel="preconnect" href="https://gstatic.loli.net" crossorigin><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;500;600;700&amp;display=swap"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构</h1><a id="logo" href="/.">Polarwanderer</a><p class="description">相逢的人会再相逢。</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home">Home</i></a><a href="/thoughts/"><i class="fa fa-lightbulb-o"> Thoughts</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构</h1><div class="post-meta">2025-03-25<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.2k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 26</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2025/03/25/1556/#waline"><span class="waline-comment-count" id="/2025/03/25/1556/"></span><span> Comment</span></a><div class="post-content"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="核心概念定义"><a href="#核心概念定义" class="headerlink" title="核心概念定义"></a>核心概念定义</h2><ol><li><p><strong>数据（Data）</strong>：信息的载体，是计算机程序加工处理的原料。数据本身没有意义，只有通过解释才能成为有用的信息。</p></li><li><p><strong>数据元素（Data Element）</strong>：数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可以由若干个数据项组成。例如：学生记录就是一个数据元素。</p></li><li><p><strong>数据项（Data Item）</strong>：构成数据元素的最小单位，是不可分割的原子数据。例如：学号、姓名、年龄等。</p></li><li><p><strong>数据对象（Data Object）</strong>：具有相同性质的数据元素的集合，是数据的一个子集。例如：所有学生记录构成的集合。</p></li></ol><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p><strong>数据类型（Data Type）</strong>：一个值的集合和定义在此集合上的一组操作的总称。</p><ul><li><strong>原子类型</strong>：其值不可再分的数据类型（如整型、字符型）</li><li><strong>结构类型</strong>：其值可以再分解为若干成分的数据类型（如数组、结构体）</li><li><strong>抽象数据类型（ADT）</strong>：一个数学模型及定义在该数学模型上的一组操作。它是对数据的逻辑抽象，定义了数据的取值范围、结构形式以及操作集合，与具体实现无关。</li></ul><h2 id="数据结构核心概念"><a href="#数据结构核心概念" class="headerlink" title="数据结构核心概念"></a>数据结构核心概念</h2><p><strong>数据结构（Data Structure）</strong>：相互之间存在一种或多种特定关系的数据元素的集合。数据元素相互之间的关系称为<strong>结构</strong>。</p><p><strong>数据结构三要素</strong>：</p><ul><li><strong>逻辑结构</strong>：数据元素间的逻辑关系</li><li><strong>存储结构</strong>：数据在计算机中的存储方式</li><li><strong>数据运算</strong>：定义在逻辑结构上的操作集合</li></ul><p><strong>数据结构研究内容</strong>：</p><ul><li>数据如何组织（逻辑结构设计）</li><li>数据如何存储（物理结构选择）</li><li>数据如何运算（算法设计与实现）</li></ul><p><strong>重要关系</strong>：</p><ul><li>算法设计取决于选定的<strong>逻辑结构</strong></li><li>算法实现依赖于采用的<strong>存储结构</strong></li></ul><h2 id="逻辑结构分类"><a href="#逻辑结构分类" class="headerlink" title="逻辑结构分类"></a>逻辑结构分类</h2><p><strong>逻辑结构</strong>：数据元素之间的逻辑关系，从逻辑关系上描述数据，<strong>与具体存储方式无关</strong>。</p><table><thead><tr><th>结构类型</th><th>关系特征</th><th>典型实例</th><th>特点说明</th></tr></thead><tbody><tr><td>集合结构</td><td>无特定关系</td><td>数学集合</td><td>元素间无逻辑关系</td></tr><tr><td><strong>线性结构</strong></td><td>一对一</td><td>线性表&#x2F;栈&#x2F;队列&#x2F;串</td><td>有唯一前驱和后继</td></tr><tr><td>树形结构</td><td>一对多</td><td>树&#x2F;二叉树</td><td>分层次的层次结构</td></tr><tr><td>图状结构</td><td>多对多</td><td>有向图&#x2F;无向图</td><td>任意复杂的网状关系</td></tr></tbody></table><h2 id="存储结构分类"><a href="#存储结构分类" class="headerlink" title="存储结构分类"></a>存储结构分类</h2><p><strong>存储结构</strong>：数据结构在计算机中的表示方式，也称<strong>物理结构</strong>。包括数据元素的存储和关系的存储两个方面。</p><table><thead><tr><th>存储类型</th><th>存储特点</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>顺序存储</td><td>逻辑相邻的元素物理相邻</td><td>支持随机存取，存储密度高</td><td>插入删除需移动大量元素</td></tr><tr><td>链式存储</td><td>用指针显式表示逻辑关系</td><td>插入删除操作灵活高效</td><td>只能顺序存取，额外指针开销</td></tr><tr><td>索引存储</td><td>建立索引表存储元素地址</td><td>检索速度快</td><td>需要额外索引空间</td></tr><tr><td>散列存储</td><td>通过哈希函数计算存储位置</td><td>平均查找时间为O(1)</td><td>可能产生哈希冲突</td></tr></tbody></table><h1 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h1><h2 id="算法基本概念"><a href="#算法基本概念" class="headerlink" title="算法基本概念"></a>算法基本概念</h2><p><strong>算法（Algorithm）</strong>：对特定问题求解步骤的一种描述，是指令的有限序列。每条指令表示一个或多个操作。</p><p><strong>算法本质</strong>：</p><ul><li>是问题求解过程的精确描述</li><li>由一系列明确的计算步骤组成</li><li>能够将输入转换为相应的输出</li></ul><h2 id="算法的五个基本特性"><a href="#算法的五个基本特性" class="headerlink" title="算法的五个基本特性"></a>算法的五个基本特性</h2><table><thead><tr><th>特性</th><th>具体要求</th><th>说明与示例</th></tr></thead><tbody><tr><td><strong>有穷性</strong></td><td>算法必须在有限步骤后终止，每步在有限时间完成</td><td>区别于操作系统等无限运行程序</td></tr><tr><td><strong>确定性</strong></td><td>每条指令含义明确，相同输入产生相同输出</td><td>不允许有二义性的操作</td></tr><tr><td><strong>可行性</strong></td><td>每个操作都能通过基本运算在有限时间内实现</td><td>算法在理论和实践上都可执行</td></tr><tr><td><strong>输入</strong></td><td>有零个或多个来自特定对象集合的输入</td><td>可以无输入（如随机数生成）</td></tr><tr><td><strong>输出</strong></td><td>有一个或多个与输入有特定关系的输出</td><td>必须有输出，体现算法价值</td></tr></tbody></table><h2 id="算法质量评价标准"><a href="#算法质量评价标准" class="headerlink" title="算法质量评价标准"></a>算法质量评价标准</h2><table><thead><tr><th>评价指标</th><th>具体要求</th><th>评估方法</th></tr></thead><tbody><tr><td><strong>正确性</strong></td><td>能够正确解决问题</td><td>理论证明+测试用例验证</td></tr><tr><td><strong>可读性</strong></td><td>算法易于理解和实现</td><td>清晰的逻辑结构和注释</td></tr><tr><td><strong>健壮性</strong></td><td>能处理异常和边界情况</td><td>输入验证和错误处理</td></tr><tr><td><strong>时间效率</strong></td><td>运行时间尽可能短</td><td>时间复杂度分析</td></tr><tr><td><strong>空间效率</strong></td><td>存储空间占用尽可能少</td><td>空间复杂度分析</td></tr></tbody></table><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>基本概念</strong>：</p><ul><li><strong>语句频度</strong>：算法中语句的执行次数</li><li><strong>时间函数T(n)</strong>：算法执行时间与问题规模n的关系</li><li><strong>渐近时间复杂度O(n)</strong>：当n趋于无穷大时T(n)的数量级</li></ul><p><strong>常见时间复杂度</strong>：</p><table><thead><tr><th>复杂度</th><th>名称</th><th>典型算法示例</th><th>性能特点</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>常数复杂度</td><td>数组随机访问</td><td>最优，不随n变化</td></tr><tr><td><strong>O(log n)</strong></td><td>对数复杂度</td><td>二分查找</td><td>优秀，增长缓慢</td></tr><tr><td><strong>O(n)</strong></td><td>线性复杂度</td><td>顺序查找</td><td>良好，线性增长</td></tr><tr><td><strong>O(n log n)</strong></td><td>线性对数复杂度</td><td>归并排序、堆排序</td><td>较好，最优比较排序</td></tr><tr><td><strong>O(n²)</strong></td><td>平方复杂度</td><td>冒泡排序、选择排序</td><td>一般，适用小规模</td></tr><tr><td><strong>O(2ⁿ)</strong></td><td>指数复杂度</td><td>汉诺塔问题</td><td>差，仅适用极小规模</td></tr></tbody></table><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>基本概念</strong>：算法执行过程中所需存储空间与问题规模n的关系。</p><p><strong>空间组成</strong>：</p><ul><li><strong>固定空间</strong>：算法本身所需的空间（指令、常量、简单变量）</li><li><strong>可变空间</strong>：算法执行中动态申请的空间（递归栈、动态数组等）</li></ul><p><strong>常见空间复杂度</strong>：</p><table><thead><tr><th>复杂度</th><th>空间特点</th><th>典型示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>O(1)</strong></td><td>常数空间</td><td>冒泡排序</td><td>原地算法，最优</td></tr><tr><td><strong>O(n)</strong></td><td>线性空间</td><td>归并排序</td><td>需要辅助数组</td></tr><tr><td><strong>O(log n)</strong></td><td>对数空间</td><td>快速排序递归</td><td>递归调用栈</td></tr></tbody></table><h2 id="算法分析方法"><a href="#算法分析方法" class="headerlink" title="算法分析方法"></a>算法分析方法</h2><h3 id="递归算法分析"><a href="#递归算法分析" class="headerlink" title="递归算法分析"></a>递归算法分析</h3><table><thead><tr><th>分析方法</th><th>适用场景</th><th>核心思想</th></tr></thead><tbody><tr><td><strong>递推公式法</strong></td><td>标准分治算法</td><td>建立递推关系T(n)&#x3D;aT(n&#x2F;b)+f(n)</td></tr><tr><td><strong>递归树法</strong></td><td>复杂递归结构</td><td>可视化递归调用过程</td></tr><tr><td><strong>主定理法</strong></td><td>特定递推形式</td><td>直接套用公式求解</td></tr></tbody></table><h3 id="算法优化策略"><a href="#算法优化策略" class="headerlink" title="算法优化策略"></a>算法优化策略</h3><table><thead><tr><th>优化策略</th><th>实现思路</th><th>效果示例</th></tr></thead><tbody><tr><td><strong>时空权衡</strong></td><td>用空间换取时间</td><td>哈希表：O(n)→O(1)</td></tr><tr><td><strong>分治策略</strong></td><td>分解子问题并合并</td><td>排序：O(n²)→O(n log n)</td></tr><tr><td><strong>动态规划</strong></td><td>保存子问题解</td><td>斐波那契：O(2ⁿ)→O(n)</td></tr><tr><td><strong>贪心算法</strong></td><td>局部最优选择</td><td>某些优化问题的高效解</td></tr></tbody></table><h1 id="重点知识总结"><a href="#重点知识总结" class="headerlink" title="重点知识总结"></a>重点知识总结</h1><h2 id="核心概念辨析"><a href="#核心概念辨析" class="headerlink" title="核心概念辨析"></a>核心概念辨析</h2><h3 id="数据类型分类-1"><a href="#数据类型分类-1" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><table><thead><tr><th>分类标准</th><th>类型</th><th>定义特征</th><th>典型示例</th></tr></thead><tbody><tr><td><strong>按元素类型</strong></td><td>单型数据类型</td><td>所有元素类型相同</td><td>整型数组、字符串</td></tr><tr><td></td><td>多型数据类型</td><td>可包含不同类型元素</td><td>结构体、联合体</td></tr><tr><td><strong>按结构复杂度</strong></td><td>原子类型</td><td>值不可再分</td><td>int、char、float</td></tr><tr><td></td><td>结构类型</td><td>值可分解为多个成分</td><td>数组、记录</td></tr><tr><td></td><td>抽象数据类型</td><td>逻辑结构+操作集合</td><td>栈、队列、树</td></tr></tbody></table><h3 id="数据结构与数据类型对比"><a href="#数据结构与数据类型对比" class="headerlink" title="数据结构与数据类型对比"></a>数据结构与数据类型对比</h3><table><thead><tr><th>概念</th><th>形式化表示</th><th>核心要素</th><th>关注重点</th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>(D, R)</td><td>D: 数据对象<br>R: 数据关系</td><td>数据的组织形式</td></tr><tr><td><strong>数据类型</strong></td><td>(D, R, P)</td><td>增加P: 基本操作集</td><td>数据的操作接口</td></tr></tbody></table><h2 id="易混概念辨析"><a href="#易混概念辨析" class="headerlink" title="易混概念辨析"></a>易混概念辨析</h2><h3 id="数据相关概念层次"><a href="#数据相关概念层次" class="headerlink" title="数据相关概念层次"></a>数据相关概念层次</h3><table><thead><tr><th>概念层次</th><th>定义</th><th>关键特征</th><th>实例说明</th></tr></thead><tbody><tr><td><strong>数据项</strong></td><td>数据的最小单位</td><td>不可分割的原子数据</td><td>学生记录中的”学号”</td></tr><tr><td><strong>数据元素</strong></td><td>数据的基本单位</td><td>由若干数据项组成</td><td>完整的学生记录</td></tr><tr><td><strong>数据对象</strong></td><td>数据元素的集合</td><td>性质相同的元素集合</td><td>所有学生记录的集合</td></tr><tr><td><strong>数据结构</strong></td><td>带关系的数据对象</td><td>元素间存在特定关系</td><td>按学号排序的学生表</td></tr></tbody></table><h3 id="结构分类对比"><a href="#结构分类对比" class="headerlink" title="结构分类对比"></a>结构分类对比</h3><table><thead><tr><th>结构类型</th><th>关系表示方式</th><th>存储特点</th><th>典型应用</th></tr></thead><tbody><tr><td><strong>逻辑结构</strong></td><td>抽象的逻辑关系</td><td>与存储方式无关</td><td>算法设计依据</td></tr><tr><td><strong>存储结构</strong></td><td>物理存储映射</td><td>包含数据和关系存储</td><td>算法实现基础</td></tr></tbody></table><p><strong>存储结构具体实现</strong>：</p><table><thead><tr><th>存储方式</th><th>关系表示</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td><strong>顺序存储</strong></td><td>物理位置隐含关系</td><td>随机访问，存储紧凑</td><td>插入删除代价高</td></tr><tr><td><strong>链式存储</strong></td><td>指针显式表示关系</td><td>动态分配，操作灵活</td><td>额外空间，顺序访问</td></tr></tbody></table><p><strong>时间复杂度分析</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>关键点</th><th>经典案例</th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>最坏情况下执行时间的上界</td><td>取决于：<br>• 问题规模(n)<br>• 数据初态</td><td>汉诺塔O(2ⁿ)</td></tr><tr><td><strong>基本操作</strong></td><td>最深层循环内的操作</td><td>统计执行次数</td><td>循环体内的核心操作</td></tr></tbody></table><p><strong>常见误区澄清</strong></p><table><thead><tr><th>错误观点</th><th>正解</th><th>反例</th></tr></thead><tbody><tr><td>“所有数据结构都有插入、删除、查找”</td><td>基本操作取决于结构特性</td><td>二维数组无插入删除功能</td></tr><tr><td>“存储结构需要额外存储元素关系”</td><td>顺序存储通过物理位置隐含关系</td><td>数组不需要指针表示相邻关系</td></tr></tbody></table><p><strong>设计原则</strong></p><table><thead><tr><th>原则</th><th>内涵</th><th>实践意义</th></tr></thead><tbody><tr><td><strong>抽象封装</strong></td><td>定义与实现分离</td><td>数据结构变化不影响应用</td></tr><tr><td><strong>操作独立性</strong></td><td>应用与存储结构解耦</td><td>便于底层优化调整</td></tr></tbody></table><p><strong>抽象数据类型(ADT)</strong></p><table><thead><tr><th>特征</th><th>说明</th><th>设计要点</th></tr></thead><tbody><tr><td><strong>逻辑特性优先</strong></td><td>仅关注数学特性</td><td>定义规范接口</td></tr><tr><td><strong>实现无关性</strong></td><td>不限定内部表示</td><td>允许性能优化</td></tr><tr><td><strong>稳定性</strong></td><td>接口不变则外部无感知</td><td>契约式编程</td></tr></tbody></table><p><strong>补充说明</strong></p><ol><li><p><strong>汉诺塔复杂度证明</strong>：</p><ul><li>递推式：T(n) &#x3D; 2T(n-1) + 1</li><li>解方程得O(2ⁿ)</li></ul></li><li><p><strong>操作设计准则</strong>：</p><ul><li>基本操作应完备且正交</li><li>避免暴露内部实现细节</li></ul></li><li><p><strong>物理结构本质</strong>：</p><ul><li>必须完整存储：<ul><li>数据元素本身</li><li>元素间逻辑关系的物理表示</li></ul></li></ul></li><li><p>【习题】数据结构被形式定义为（D，S), 其中D是<code>( )</code>的有限集合，S是D上的<code>( )</code>有限的集合。</p><p>A、算法</p><p>B、数据元素</p><p>C、数据操作</p><p>D、逻辑结构</p><p>E、操作</p><p>F、映像</p><p>G、存储</p><p>H、关系</p></li></ol><blockquote><p>正确答案：<em><strong>BH</strong></em></p></blockquote><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p><strong>线性表（Linear List）</strong>：由n（n≥0）个具有相同数据类型的数据元素组成的有限序列。</p><p><strong>数学表示</strong>：L &#x3D; (a₁, a₂, a₃, …, aₙ)</p><ul><li>其中aᵢ是线性表中的第i个元素（1≤i≤n）</li><li>n为线性表的长度，当n&#x3D;0时称为空表</li><li>a₁是表头元素，aₙ是表尾元素</li></ul><h2 id="线性表的逻辑特征"><a href="#线性表的逻辑特征" class="headerlink" title="线性表的逻辑特征"></a>线性表的逻辑特征</h2><table><thead><tr><th>特征</th><th>具体描述</th><th>重要性说明</th></tr></thead><tbody><tr><td><strong>有限性</strong></td><td>元素个数有限</td><td>区别于无限序列</td></tr><tr><td><strong>同质性</strong></td><td>所有元素具有相同的数据类型</td><td>保证操作的一致性</td></tr><tr><td><strong>序列性</strong></td><td>元素在逻辑上有先后顺序</td><td>体现线性关系的本质</td></tr><tr><td><strong>唯一性</strong></td><td>除首尾元素外，每个元素有唯一前驱和后继</td><td>一对一的线性关系</td></tr><tr><td><strong>抽象性</strong></td><td>只关注逻辑关系，不涉及具体存储方式</td><td>便于算法设计和分析</td></tr></tbody></table><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><h3 id="核心操作定义"><a href="#核心操作定义" class="headerlink" title="核心操作定义"></a>核心操作定义</h3><table><thead><tr><th>操作类型</th><th>函数原型</th><th>功能描述</th><th>返回值说明</th></tr></thead><tbody><tr><td><strong>初始化</strong></td><td><code>InitList(&amp;L)</code></td><td>构造一个空的线性表L</td><td>成功返回OK</td></tr><tr><td><strong>销毁</strong></td><td><code>DestroyList(&amp;L)</code></td><td>销毁线性表并释放内存空间</td><td>成功返回OK</td></tr><tr><td><strong>插入</strong></td><td><code>ListInsert(&amp;L, i, e)</code></td><td>在第i个位置插入元素e</td><td>成功返回OK</td></tr><tr><td><strong>删除</strong></td><td><code>ListDelete(&amp;L, i, &amp;e)</code></td><td>删除第i个位置的元素</td><td>成功返回OK，e返回删除值</td></tr><tr><td><strong>按值查找</strong></td><td><code>LocateElem(L, e)</code></td><td>查找值为e的元素位置</td><td>返回位置，失败返回0</td></tr><tr><td><strong>按位查找</strong></td><td><code>GetElem(L, i)</code></td><td>获取第i个位置的元素值</td><td>返回元素值</td></tr><tr><td><strong>求长度</strong></td><td><code>Length(L)</code></td><td>返回线性表的元素个数</td><td>返回长度值</td></tr><tr><td><strong>判空</strong></td><td><code>Empty(L)</code></td><td>判断线性表是否为空</td><td>空返回true</td></tr></tbody></table><h3 id="操作的前置条件"><a href="#操作的前置条件" class="headerlink" title="操作的前置条件"></a>操作的前置条件</h3><table><thead><tr><th>操作</th><th>前置条件</th><th>异常处理</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>1≤i≤n+1，表未满</td><td>位置非法或表满时失败</td></tr><tr><td><strong>删除</strong></td><td>1≤i≤n，表非空</td><td>位置非法或表空时失败</td></tr><tr><td><strong>按位查找</strong></td><td>1≤i≤n，表非空</td><td>位置非法时返回错误</td></tr><tr><td><strong>按值查找</strong></td><td>表非空，元素类型支持比较操作</td><td>未找到时返回0</td></tr></tbody></table><h2 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h2><h3 id="顺序存储结构（顺序表）"><a href="#顺序存储结构（顺序表）" class="headerlink" title="顺序存储结构（顺序表）"></a>顺序存储结构（顺序表）</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>顺序表（Sequential List）</strong>：用一组地址连续的存储单元依次存储线性表的数据元素。</p><p><strong>存储特点</strong>：</p><ul><li>逻辑上相邻的元素在物理上也相邻</li><li>可以随机访问表中任一元素</li><li>存储密度高（存储密度 &#x3D; 1）</li></ul><h4 id="顺序表的实现方式"><a href="#顺序表的实现方式" class="headerlink" title="顺序表的实现方式"></a>顺序表的实现方式</h4><table><thead><tr><th>实现方式</th><th>存储分配</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>静态分配</strong></td><td>编译时确定</td><td>实现简单，访问效率高</td><td>容量固定，空间利用率低</td><td>表长变化不大</td></tr><tr><td><strong>动态分配</strong></td><td>运行时分配</td><td>容量可变，空间利用率高</td><td>实现复杂，可能内存碎片</td><td>表长变化较大</td></tr></tbody></table><h4 id="顺序表的基本操作及复杂度"><a href="#顺序表的基本操作及复杂度" class="headerlink" title="顺序表的基本操作及复杂度"></a>顺序表的基本操作及复杂度</h4><table><thead><tr><th>操作类型</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th><th>空间复杂度</th><th>操作特点</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要移动元素</td></tr><tr><td><strong>删除</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要移动元素</td></tr><tr><td><strong>按位查找</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>随机访问优势</td></tr><tr><td><strong>按值查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序扫描</td></tr></tbody></table><h3 id="链式存储结构（链表）"><a href="#链式存储结构（链表）" class="headerlink" title="链式存储结构（链表）"></a>链式存储结构（链表）</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>链表（Linked List）</strong>：用一组任意的存储单元存储线性表的数据元素，通过指针链接各元素。</p><p><strong>存储特点</strong>：</p><ul><li>逻辑上相邻的元素在物理上不一定相邻</li><li>只能顺序访问，不支持随机访问</li><li>存储密度小于1（需要额外存储指针）</li></ul><h4 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h4><table><thead><tr><th>链表类型</th><th>结构特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>单链表</strong></td><td>每个节点只有一个指针域</td><td>实现简单，空间开销小</td><td>只能单向遍历</td><td>一般的线性表操作</td></tr><tr><td><strong>双链表</strong></td><td>每个节点有前驱和后继指针</td><td>可双向遍历，删除方便</td><td>空间开销大</td><td>需要双向操作的场景</td></tr><tr><td><strong>循环链表</strong></td><td>尾节点指向头节点</td><td>便于循环操作</td><td>实现稍复杂</td><td>循环处理的应用</td></tr><tr><td><strong>静态链表</strong></td><td>用数组模拟链表结构</td><td>不需要指针，便于调试</td><td>容量固定</td><td>不支持指针的语言</td></tr></tbody></table><h4 id="链表的基本操作及复杂度"><a href="#链表的基本操作及复杂度" class="headerlink" title="链表的基本操作及复杂度"></a>链表的基本操作及复杂度</h4><table><thead><tr><th>操作类型</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th><th>空间复杂度</th><th>操作特点</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要先定位到位置</td></tr><tr><td><strong>删除</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要先定位到位置</td></tr><tr><td><strong>按位查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序遍历</td></tr><tr><td><strong>按值查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序遍历</td></tr></tbody></table><h3 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h3><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><table><thead><tr><th>比较维度</th><th>顺序表</th><th>链表</th><th>选择建议</th></tr></thead><tbody><tr><td><strong>存储密度</strong></td><td>高（&#x3D;1）</td><td>低（&lt;1）</td><td>空间要求高选顺序表</td></tr><tr><td><strong>随机访问</strong></td><td>支持，O(1)</td><td>不支持，O(n)</td><td>需要随机访问选顺序表</td></tr><tr><td><strong>插入删除</strong></td><td>平均O(n)，需移动元素</td><td>平均O(n)，但不移动元素</td><td>频繁插删选链表</td></tr><tr><td><strong>内存分配</strong></td><td>连续分配</td><td>离散分配</td><td>内存紧张选顺序表</td></tr><tr><td><strong>缓存性能</strong></td><td>好（局部性原理）</td><td>差（指针跳转）</td><td>性能要求高选顺序表</td></tr></tbody></table><h4 id="应用场景选择"><a href="#应用场景选择" class="headerlink" title="应用场景选择"></a>应用场景选择</h4><table><thead><tr><th>应用特点</th><th>推荐存储结构</th><th>理由说明</th></tr></thead><tbody><tr><td>表长基本稳定，查找频繁</td><td>顺序表</td><td>随机访问优势明显</td></tr><tr><td>表长变化大，插删频繁</td><td>链表</td><td>避免大量元素移动</td></tr><tr><td>对存储空间要求严格</td><td>顺序表</td><td>存储密度高，无额外指针开销</td></tr><tr><td>需要双向遍历</td><td>双链表</td><td>支持前驱访问</td></tr><tr><td>实现简单，开发效率优先</td><td>顺序表</td><td>实现和调试相对简单</td></tr></tbody></table><h2 id="线性表的应用与算法复杂度分析"><a href="#线性表的应用与算法复杂度分析" class="headerlink" title="线性表的应用与算法复杂度分析"></a>线性表的应用与算法复杂度分析</h2><p>理解线性表不仅要掌握其理论定义和基本操作，更要能在实际问题中根据性能需求选择合适的存储结构。本章将深入探讨顺序表和链表的算法复杂度，并结合典型应用场景进行分析。</p><h3 id="核心操作复杂度对比"><a href="#核心操作复杂度对比" class="headerlink" title="核心操作复杂度对比"></a>核心操作复杂度对比</h3><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><table><thead><tr><th align="left">操作类型</th><th align="left">顺序表 (平均)</th><th align="left">顺序表 (最坏)</th><th align="left">链表 (平均)</th><th align="left">链表 (最坏)</th><th align="left">关键影响因素</th></tr></thead><tbody><tr><td align="left"><strong>按位查找 (GetElem)</strong></td><td align="left"><strong>O(1)</strong></td><td align="left">O(1)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：基于地址偏移计算，与位置无关。<br><strong>链表</strong>：需从头节点开始顺序遍历。</td></tr><tr><td align="left"><strong>按值查找 (LocateElem)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">无论顺序表还是链表，都需要逐一比较元素值。</td></tr><tr><td align="left"><strong>插入 (Insert)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：主要开销在于移动插入位置后的所有元素。<br><strong>链表</strong>：主要开销在于查找到插入位置的前驱节点。</td></tr><tr><td align="left"><strong>删除 (Delete)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：主要开销在于移动删除位置后的所有元素。<br><strong>链表</strong>：主要开销在于查找到待删除节点的前驱节点。</td></tr><tr><td align="left"><strong>在指定节点后插入</strong></td><td align="left">-</td><td align="left">-</td><td align="left"><strong>O(1)</strong></td><td align="left">O(1)</td><td align="left"><strong>链表</strong>：若已持有前驱节点的指针，则插入操作仅需修改指针，与表长无关。</td></tr><tr><td align="left"><strong>删除指定节点</strong></td><td align="left">-</td><td align="left">-</td><td align="left"><strong>O(1)</strong> (双链表) &#x2F; O(n) (单链表)</td><td align="left">O(1) &#x2F; O(n)</td><td align="left"><strong>双链表</strong>：若持有待删除节点的指针，可直接获取前驱，O(1)完成。<br><strong>单链表</strong>：仍需O(n)查找前驱。</td></tr></tbody></table><p><strong>核心结论</strong>：</p><ul><li><strong>随机访问</strong>是顺序表的核心优势。</li><li><strong>插入&#x2F;删除</strong>的效率取决于<strong>查找</strong>的效率。链表在<strong>已知节点</strong>的情况下进行插入&#x2F;删除操作具有巨大优势。</li></ul><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><table><thead><tr><th align="left">存储结构</th><th align="left">空间复杂度</th><th align="left">存储密度</th><th align="left">内存分配特点</th></tr></thead><tbody><tr><td align="left"><strong>顺序表</strong></td><td align="left"><strong>O(n)</strong></td><td align="left"><strong>1</strong></td><td align="left"><strong>整块分配</strong>：需要一块连续的内存空间，可能会因容量不足导致频繁的内存重分配和数据复制。</td></tr><tr><td align="left"><strong>链表</strong></td><td align="left"><strong>O(n)</strong></td><td align="left"><strong>&lt; 1</strong></td><td align="left"><strong>离散分配</strong>：每个节点独立分配内存，通过指针连接。空间利用率更高，但有额外的指针开销。</td></tr></tbody></table><h3 id="典型应用场景分析"><a href="#典型应用场景分析" class="headerlink" title="典型应用场景分析"></a>典型应用场景分析</h3><h4 id="顺序表的应用场景"><a href="#顺序表的应用场景" class="headerlink" title="顺序表的应用场景"></a>顺序表的应用场景</h4><p>顺序表凭借其<strong>O(1)的随机访问</strong>能力和<strong>良好的缓存局部性</strong>，在以下场景中表现出色：</p><table><thead><tr><th align="left">应用领域</th><th align="left">具体案例</th><th align="left">优势分析</th></tr></thead><tbody><tr><td align="left"><strong>科学计算与数据分析</strong></td><td align="left"><strong>矩阵&#x2F;向量运算</strong>、<strong>NumPy&#x2F;Pandas库</strong></td><td align="left">底层采用连续内存数组，完美契合CPU缓存机制，数值计算和数据处理性能极高。</td></tr><tr><td align="left"><strong>高效查找算法</strong></td><td align="left"><strong>二分查找</strong>、<strong>哈希表（开放地址法）</strong></td><td align="left">这些算法都要求能够快速访问任意位置的元素，顺序表是其实现的天然基础。</td></tr><tr><td align="left"><strong>CPU缓存与内存管理</strong></td><td align="left"><strong>高速缓存行 (Cache Line)</strong></td><td align="left">CPU从内存加载数据时，会一次性加载一个连续的数据块（缓存行），顺序表的物理连续性使其缓存命中率远高于链表。</td></tr><tr><td align="left"><strong>作为其他数据结构的底层实现</strong></td><td align="left"><strong>堆（Heap）</strong>、<strong>哈希表</strong></td><td align="left">完全二叉树（堆的逻辑结构）可以用数组完美表示，利用索引即可计算父子关系，无需指针。</td></tr></tbody></table><h4 id="链表的应用场景"><a href="#链表的应用场景" class="headerlink" title="链表的应用场景"></a>链表的应用场景</h4><p>链表的核心优势在于<strong>高效的、动态的插入和删除操作</strong>，尤其适用于表长频繁变化或需要高效节点操作的场景。</p><table><thead><tr><th align="left">应用领域</th><th align="left">具体案例</th><th align="left">优势分析</th></tr></thead><tbody><tr><td align="left"><strong>操作系统</strong></td><td align="left"><strong>进程管理</strong>、<strong>文件系统</strong></td><td align="left">进程的创建和销毁、空闲磁盘块的管理，都涉及频繁的、动态的插入和删除，链表是理想选择。</td></tr><tr><td align="left"><strong>内存管理</strong></td><td align="left"><strong>内存池 (Memory Pool)</strong>、<strong>伙伴系统 (Buddy System)</strong></td><td align="left">用于管理空闲内存块，当程序申请或释放内存时，可以高效地从链表中添加或移除相应大小的内存块。</td></tr><tr><td align="left"><strong>数据结构实现</strong></td><td align="left"><strong>图的邻接表</strong>、<strong>哈希表（拉链法）</strong></td><td align="left">当图的顶点度数差异很大时，邻接表（由链表数组构成）能有效节省空间。拉链法解决哈希冲突时，每个桶位都是一个链表。</td></tr><tr><td align="left"><strong>缓存淘汰算法</strong></td><td align="left"><strong>LRU (Least Recently Used) 缓存</strong></td><td align="left">LRU要求能快速将最新访问的元素移到表头，并淘汰表尾元素。使用<strong>双向链表</strong>配合哈希表，可实现O(1)时间的访问和淘汰操作。</td></tr></tbody></table><h4 id="案例研究：LRU缓存淘汰算法"><a href="#案例研究：LRU缓存淘汰算法" class="headerlink" title="案例研究：LRU缓存淘汰算法"></a>案例研究：LRU缓存淘汰算法</h4><p><strong>问题描述</strong>：设计一个容量有限的缓存，当缓存满时，需要淘汰最近最少使用的数据。</p><p><strong>解决方案</strong>：使用一个<strong>哈希表 (HashMap)</strong> 和一个<strong>双向链表 (Doubly Linked List)</strong>。</p><ul><li><strong>哈希表</strong>：存储键 (key) 到双向链表节点 (Node) 的映射，实现O(1)时间的快速查找。</li><li><strong>双向链表</strong>：维护数据的“新鲜度”。链表头部是最新访问的，尾部是最久未访问的。</li></ul><table><thead><tr><th align="left">操作</th><th align="left">实现流程</th><th align="left">复杂度</th></tr></thead><tbody><tr><td align="left"><strong>访问数据 (get)</strong></td><td align="left">1. 通过哈希表找到节点。<br>2. 将该节点从链表中移动到头部。<br>3. 返回节点值。</td><td align="left"><strong>O(1)</strong></td></tr><tr><td align="left"><strong>插入数据 (put)</strong></td><td align="left">1. <strong>若已存在</strong>：更新值，并将节点移到链表头部。<br>2. <strong>若不存在</strong>：<br>a. 创建新节点，插入链表头部。<br>b. 在哈希表中添加映射。<br>c. <strong>若缓存已满</strong>：删除链表尾部节点，并从哈希表中移除对应映射。</td><td align="left"><strong>O(1)</strong></td></tr></tbody></table><p><strong>为什么是双向链表？</strong><br>因为在移动或删除节点时，需要同时修改其<strong>前驱节点</strong>和<strong>后继节点</strong>的指针。双向链表可以在O(1)时间内完成这些操作，而单链表则需要O(n)时间来查找前驱节点。</p><h3 id="存储结构选择策略"><a href="#存储结构选择策略" class="headerlink" title="存储结构选择策略"></a>存储结构选择策略</h3><table><thead><tr><th align="left">决策依据</th><th align="left">优先选择顺序表</th><th align="left">优先选择链表</th></tr></thead><tbody><tr><td align="left"><strong>核心操作</strong></td><td align="left"><strong>查找&#x2F;访问</strong> 操作远多于插入&#x2F;删除</td><td align="left"><strong>插入&#x2F;删除</strong> 操作远多于查找&#x2F;访问</td></tr><tr><td align="left"><strong>表长变化</strong></td><td align="left">表长基本固定或变化不大</td><td align="left">表长频繁变化，难以预估</td></tr><tr><td align="left"><strong>内存要求</strong></td><td align="left">内存空间有限，要求<strong>高存储密度</strong></td><td align="left">内存空间充裕，可接受指针开销</td></tr><tr><td align="left"><strong>性能要求</strong></td><td align="left">追求极致的<strong>缓存性能</strong>和计算速度</td><td align="left">对随机访问性能要求不高</td></tr></tbody></table><h2 id="常见面试题与解题思路"><a href="#常见面试题与解题思路" class="headerlink" title="常见面试题与解题思路"></a>常见面试题与解题思路</h2><p>本章将精选关于线性表的常见面试题，提供详细的解题思路、多种实现方法以及完整的C++代码，帮助你巩固知识，从容应对面试。</p><h3 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h3><p><strong>问题描述</strong>：给定一个单链表的头节点，将其反转，并返回反转后链表的头节点。</p><p><strong>解题思路</strong>：<br>这是链表操作中最经典、最基础的题目之一。核心思想是改变节点的<code>next</code>指针的指向，使其指向其前一个节点。</p><ul><li><p><strong>迭代法</strong>：推荐使用此方法，因为它空间复杂度为O(1)，且逻辑清晰。需要三个指针：</p><ul><li><code>pre</code>：指向当前节点的前一个节点，初始为<code>nullptr</code>。</li><li><code>cur</code>：指向当前正在处理的节点，初始为<code>head</code>。</li><li><code>next</code>：临时保存当前节点的下一个节点，防止链表断裂。</li></ul><p>遍历链表，依次将<code>cur</code>的<code>next</code>指针指向<code>pre</code>，然后同步向后移动<code>pre</code>和<code>cur</code>。</p></li><li><p><strong>递归法</strong>：思路更巧妙，但空间复杂度为O(n)，且可能因递归深度过大导致栈溢出。</p><ul><li>递归的终止条件是链表为空或只有一个节点。</li><li>递归调用<code>reverseList(head-&gt;next)</code>，得到反转后的子链表的头节点<code>newHead</code>。</li><li>将<code>head-&gt;next</code>的<code>next</code>指针指向<code>head</code>，再将<code>head</code>的<code>next</code>指针设为<code>nullptr</code>。</li></ul></li></ul><p><strong>C++ 代码实现 (迭代法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = cur-&gt;next; <span class="comment">// 临时保存下一个节点</span></span><br><span class="line">            cur-&gt;next = pre;               <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">            pre = cur;                     <span class="comment">// pre后移</span></span><br><span class="line">            cur = nextTemp;                <span class="comment">// cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// 返回新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表检测"><a href="#环形链表检测" class="headerlink" title="环形链表检测"></a>环形链表检测</h3><p><strong>问题描述</strong>：给定一个链表，判断链表中是否有环。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>哈希表法</strong>：遍历链表，将每个访问过的节点的地址存入哈希表中。如果遇到一个节点已存在于哈希表中，说明链表有环。时间复杂度O(n)，空间复杂度O(n)。</p></li><li><p><strong>快慢指针法（Floyd判圈算法）</strong>：最优解法。定义两个指针<code>slow</code>和<code>fast</code>，都从头节点出发。</p><ul><li><code>slow</code>每次走一步。</li><li><code>fast</code>每次走两步。</li><li>如果链表中存在环，<code>fast</code>指针最终会从后面追上<code>slow</code>指针，两者相遇。如果<code>fast</code>或<code>fast-&gt;next</code>到达<code>nullptr</code>，则说明无环。</li></ul></li></ul><p><strong>C++ 代码实现 (快慢指针法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 快指针到达终点，无环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 快慢指针相遇，有环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p><strong>问题描述</strong>：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>迭代法</strong>：创建一个哑节点（dummy node）作为新链表的头，简化边界处理。使用一个指针<code>cur</code>指向新链表的尾部。比较两个链表的当前节点值，将较小的节点连接到<code>cur</code>后面，然后移动相应链表的指针和<code>cur</code>指针。当一个链表遍历完后，将另一个链表余下的部分直接拼接到新链表末尾。</p></li><li><p><strong>递归法</strong>：比较两个链表的头节点<code>l1</code>和<code>l2</code>。</p><ul><li>若<code>l1-&gt;val &lt; l2-&gt;val</code>，则<code>l1</code>为新链表的头，其<code>next</code>指针指向<code>mergeTwoLists(l1-&gt;next, l2)</code>的结果。</li><li>否则，<code>l2</code>为新链表的头，其<code>next</code>指针指向<code>mergeTwoLists(l1, l2-&gt;next)</code>的结果。</li><li>递归终止条件是任一链表为空。</li></ul></li></ul><p><strong>C++ 代码实现 (迭代法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 创建哑节点</span></span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接剩余部分</span></span><br><span class="line">        cur-&gt;next = (l1 != <span class="literal">nullptr</span>) ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        ListNode* head = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy; <span class="comment">// 释放哑节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h3><p><strong>问题描述</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>快慢指针法</strong>：这是解决此类问题的经典方法。定义<code>fast</code>和<code>slow</code>两个指针。</p><ol><li>让<code>fast</code>指针先从头节点走 <code>n</code> 步。</li><li>然后<code>fast</code>和<code>slow</code>指针同时向后走，直到<code>fast</code>指针到达链表末尾（<code>fast-&gt;next == nullptr</code>）。</li><li>此时，<code>slow</code>指针正好指向倒数第 <code>n+1</code> 个节点，即待删除节点的前一个节点。</li><li>修改<code>slow</code>的<code>next</code>指针，<code>slow-&gt;next = slow-&gt;next-&gt;next</code>，即可删除目标节点。</li></ol></li><li><p><strong>注意边界情况</strong>：如果删除的是头节点（即<code>n</code>等于链表长度），<code>fast</code>走完<code>n</code>步后会是<code>nullptr</code>。此时直接返回<code>head-&gt;next</code>即可。为了统一处理，可以引入哑节点。</p></li></ul><p><strong>C++ 代码实现 (快慢指针 + 哑节点)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快指针先走 n 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">ß</span><br><span class="line">        <span class="comment">// 2. 快慢指针同时走，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除目标节点</span></span><br><span class="line">        ListNode* toDelete = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://polarwanderer.cn/2025/03/25/1556/" data-id="cmkih4qf9000r8szbc3gp9c89" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABu0lEQVR42u3ay27DIBAF0Pz/T7vbSm3IvRBwWh1WkWLD8WY0Dx6PeF3f1viZn88/e2u829LCxcVd5l7DNfdMfla+Py4u7nluEpiSI8fPJ/u/sOHi4n4kd/xu/jG4uLj/iZsHpvHOuLi4n89NCpu6UAlO2Vir4eLiLnDzLuW+31v6u7i4uFPcq1zvSlOuqYWLi3uGmweUPPloB7H1cBcXF3czNw8xc+lOTk9arri4uOe5bVqTpDhtm/XFKbi4uMe57aA0KYRWEqNfzsXFxT3IXa+f8h2Wmi+4uLhHuO0BSVIyV0RFxQ8uLu4Rbtu2GIPW56R1wxQXF3cDN2lYjFsb7aWu/MSnO+Di4m7m5gXMyoXOPBRGtRouLu5mbh6e8qtXbRJTX9HAxcW9iTuHmzs+T6FwcXHv4rYFSf5vi4tqNVxc3M3cNoS1l7zbIW7xNy4u7lu5V7ny6xftPlFphIuLe4Sbr6gsKcNW3nCpPwYXF3eZu2NQmnzSXFmFi4t7kvveRufRWg0XF/cDuG14miuxcHFx/xZ3LnglpU4kxMXFPchtm5tzCVB7SRQXF/cubh1KyoHK+lgXFxf3IPcL9VS5aAOAoz8AAAAASUVORK5CYII=">Share</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94/" rel="tag">计算机考研</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/06/22/0218/">计算机网络</a><a class="next" href="/2024/07/29/0021/">浪迹天涯</a></div><div class="nofancybox" id="waline"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/@waline/client@v3/dist/waline.css"><script type="module">import{init}from"https://unpkg.com/@waline/client@v3/dist/waline.js";init({el:"#waline",comment:!0,serverURL:"comments.polarwanderer.cn",pageSize:"8",wordLimit:"120",requiredMeta:requiredMeta,emoji:["//unpkg.com/@waline/emojis@1.2.0/weibo","//unpkg.com/@waline/emojis@1.2.0/qq","//unpkg.com/@waline/emojis@1.2.0/tw-emoji"]})</script><script>let metaInfo=["nick","mail","link"],requiredMeta="nick,mail".split(",").filter(i=>metaInfo.indexOf(i)>-1)</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0" readonly></div></div><div class="search-modal" id="search-modal"><div class="search-modal-content"><div class="search-modal-header"><input class="search-modal-input" id="modal-search-input" placeholder="输入关键词搜索..." type="text" name="q"></div><div class="search-modal-body"><div id="modal-search-result"></div></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o">Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o">Tags</i></div><div class="tagcloud"><a href="/tags/408/" style="font-size:15px">408</a> <a href="/tags/AI%E5%BA%94%E7%94%A8/" style="font-size:15px">AI应用</a> <a href="/tags/React/" style="font-size:15px">React</a> <a href="/tags/TypeScript/" style="font-size:15px">TypeScript</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size:15px">个人博客</a> <a href="/tags/%E4%BA%BA%E7%89%A9/" style="font-size:15px">人物</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size:15px">前端开发</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:15px">历史</a> <a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size:15px">哲学</a> <a href="/tags/%E5%9B%9E%E5%BF%86/" style="font-size:15px">回忆</a> <a href="/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" style="font-size:15px">年终总结</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size:15px">思考</a> <a href="/tags/%E6%84%9F%E6%82%9F/" style="font-size:15px">感悟</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:15px">数学建模</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:15px">数据结构</a> <a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size:15px">日记</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:15px">机器学习</a> <a href="/tags/%E6%A2%A6%E5%A2%83/" style="font-size:15px">梦境</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:15px">生活</a> <a href="/tags/%E7%A4%BE%E4%BC%9A%E7%8E%B0%E8%B1%A1/" style="font-size:15px">社会现象</a> <a href="/tags/%E7%AB%9E%E8%B5%9B/" style="font-size:15px">竞赛</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size:15px">笔记</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:15px">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94/" style="font-size:15px">计算机考研</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size:15px">记录</a> <a href="/tags/%E9%9A%8F%E6%83%B3/" style="font-size:15px">随想</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:15px">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" style="font-size:15px">项目介绍</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o">Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/12/31/2359/">再见2025</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/17/1529/">遗憾总是贯穿人生</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/08/1813/">当AI遇见调酒师，一场数字时代的温暖邂逅</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/22/0218/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/1556/">数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/29/0021/">浪迹天涯</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/13/2215/">随想</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/08/2317/">寻书</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/25/2338/">半年志</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/02/07/2150/">2024年美赛</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o">Recent Comments</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverurl="comments.polarwanderer.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022-2026 <a href="/." rel="nofollow">Polarwanderer.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;searchFunc(path,"local-search-input","local-search-result")</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/js/sticky-header.js?v=1.0.0"></script><script type="text/javascript" src="/js/toc-generator.js?v=1.0.0"></script><script type="text/javascript" src="/js/snowfall.js?v=1.0.0"></script><script type="text/javascript" src="/js/text-reader.js?v=1.0.0"></script><script type="text/javascript" src="/js/floating-buttons.js?v=1.0.0"></script><script type="text/javascript" src="/js/random-post.js?v=1.0.0"></script><script type="text/javascript" src="/js/thoughts-typewriter.js?v=1.0.0"></script><script type="text/javascript" src="/js/subtitle-typewriter.js?v=1.0.0"></script></div></body></html>