<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>数据结构-线性表 | BlankChen</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据结构-线性表</h1><a id="logo" href="/.">BlankChen</a><p class="description">相逢的人会再相逢。</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home">Home</i></a><a class="current" href="/notes/"><i class="fa fa-sticky-note-o"> Notes</i></a><a href="/esoterica/"><i class="fa fa-eye"> Esoterica</i></a><a href="/thoughts/"><i class="fa fa-lightbulb-o"> Thoughts</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">数据结构-线性表</h1><div class="post-meta">2025-03-25<span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.6k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 17</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" href="/2025/03/25/1558/#waline"><span class="waline-comment-count" id="/2025/03/25/1558/"></span><span> Comment</span></a><div class="post-content"><h2 id="一、线性表的基本概念"><a href="#一、线性表的基本概念" class="headerlink" title="一、线性表的基本概念"></a>一、线性表的基本概念</h2><h3 id="1-1-线性表的定义"><a href="#1-1-线性表的定义" class="headerlink" title="1.1 线性表的定义"></a>1.1 线性表的定义</h3><p><strong>线性表（Linear List）</strong>：由n（n≥0）个具有相同数据类型的数据元素组成的有限序列。</p><p><strong>数学表示</strong>：L &#x3D; (a₁, a₂, a₃, …, aₙ)</p><ul><li>其中aᵢ是线性表中的第i个元素（1≤i≤n）</li><li>n为线性表的长度，当n&#x3D;0时称为空表</li><li>a₁是表头元素，aₙ是表尾元素</li></ul><h3 id="1-2-线性表的逻辑特征"><a href="#1-2-线性表的逻辑特征" class="headerlink" title="1.2 线性表的逻辑特征"></a>1.2 线性表的逻辑特征</h3><table><thead><tr><th>特征</th><th>具体描述</th><th>重要性说明</th></tr></thead><tbody><tr><td><strong>有限性</strong></td><td>元素个数有限</td><td>区别于无限序列</td></tr><tr><td><strong>同质性</strong></td><td>所有元素具有相同的数据类型</td><td>保证操作的一致性</td></tr><tr><td><strong>序列性</strong></td><td>元素在逻辑上有先后顺序</td><td>体现线性关系的本质</td></tr><tr><td><strong>唯一性</strong></td><td>除首尾元素外，每个元素有唯一前驱和后继</td><td>一对一的线性关系</td></tr><tr><td><strong>抽象性</strong></td><td>只关注逻辑关系，不涉及具体存储方式</td><td>便于算法设计和分析</td></tr></tbody></table><h3 id="1-3-线性表的基本操作"><a href="#1-3-线性表的基本操作" class="headerlink" title="1.3 线性表的基本操作"></a>1.3 线性表的基本操作</h3><h4 id="1-3-1-核心操作定义"><a href="#1-3-1-核心操作定义" class="headerlink" title="1.3.1 核心操作定义"></a>1.3.1 核心操作定义</h4><table><thead><tr><th>操作类型</th><th>函数原型</th><th>功能描述</th><th>返回值说明</th></tr></thead><tbody><tr><td><strong>初始化</strong></td><td><code>InitList(&amp;L)</code></td><td>构造一个空的线性表L</td><td>成功返回OK</td></tr><tr><td><strong>销毁</strong></td><td><code>DestroyList(&amp;L)</code></td><td>销毁线性表并释放内存空间</td><td>成功返回OK</td></tr><tr><td><strong>插入</strong></td><td><code>ListInsert(&amp;L, i, e)</code></td><td>在第i个位置插入元素e</td><td>成功返回OK</td></tr><tr><td><strong>删除</strong></td><td><code>ListDelete(&amp;L, i, &amp;e)</code></td><td>删除第i个位置的元素</td><td>成功返回OK，e返回删除值</td></tr><tr><td><strong>按值查找</strong></td><td><code>LocateElem(L, e)</code></td><td>查找值为e的元素位置</td><td>返回位置，失败返回0</td></tr><tr><td><strong>按位查找</strong></td><td><code>GetElem(L, i)</code></td><td>获取第i个位置的元素值</td><td>返回元素值</td></tr><tr><td><strong>求长度</strong></td><td><code>Length(L)</code></td><td>返回线性表的元素个数</td><td>返回长度值</td></tr><tr><td><strong>判空</strong></td><td><code>Empty(L)</code></td><td>判断线性表是否为空</td><td>空返回true</td></tr></tbody></table><h4 id="1-3-2-操作的前置条件"><a href="#1-3-2-操作的前置条件" class="headerlink" title="1.3.2 操作的前置条件"></a>1.3.2 操作的前置条件</h4><table><thead><tr><th>操作</th><th>前置条件</th><th>异常处理</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>1≤i≤n+1，表未满</td><td>位置非法或表满时失败</td></tr><tr><td><strong>删除</strong></td><td>1≤i≤n，表非空</td><td>位置非法或表空时失败</td></tr><tr><td><strong>按位查找</strong></td><td>1≤i≤n，表非空</td><td>位置非法时返回错误</td></tr><tr><td><strong>按值查找</strong></td><td>表非空，元素类型支持比较操作</td><td>未找到时返回0</td></tr></tbody></table><h2 id="二、线性表的存储结构"><a href="#二、线性表的存储结构" class="headerlink" title="二、线性表的存储结构"></a>二、线性表的存储结构</h2><h3 id="2-1-顺序存储结构（顺序表）"><a href="#2-1-顺序存储结构（顺序表）" class="headerlink" title="2.1 顺序存储结构（顺序表）"></a>2.1 顺序存储结构（顺序表）</h3><h4 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h4><p><strong>顺序表（Sequential List）</strong>：用一组地址连续的存储单元依次存储线性表的数据元素。</p><p><strong>存储特点</strong>：</p><ul><li>逻辑上相邻的元素在物理上也相邻</li><li>可以随机访问表中任一元素</li><li>存储密度高（存储密度 &#x3D; 1）</li></ul><h4 id="2-1-2-顺序表的实现方式"><a href="#2-1-2-顺序表的实现方式" class="headerlink" title="2.1.2 顺序表的实现方式"></a>2.1.2 顺序表的实现方式</h4><table><thead><tr><th>实现方式</th><th>存储分配</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>静态分配</strong></td><td>编译时确定</td><td>实现简单，访问效率高</td><td>容量固定，空间利用率低</td><td>表长变化不大</td></tr><tr><td><strong>动态分配</strong></td><td>运行时分配</td><td>容量可变，空间利用率高</td><td>实现复杂，可能内存碎片</td><td>表长变化较大</td></tr></tbody></table><h4 id="2-1-3-顺序表的基本操作及复杂度"><a href="#2-1-3-顺序表的基本操作及复杂度" class="headerlink" title="2.1.3 顺序表的基本操作及复杂度"></a>2.1.3 顺序表的基本操作及复杂度</h4><table><thead><tr><th>操作类型</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th><th>空间复杂度</th><th>操作特点</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要移动元素</td></tr><tr><td><strong>删除</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要移动元素</td></tr><tr><td><strong>按位查找</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>随机访问优势</td></tr><tr><td><strong>按值查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序扫描</td></tr></tbody></table><h3 id="2-2-链式存储结构（链表）"><a href="#2-2-链式存储结构（链表）" class="headerlink" title="2.2 链式存储结构（链表）"></a>2.2 链式存储结构（链表）</h3><h4 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h4><p><strong>链表（Linked List）</strong>：用一组任意的存储单元存储线性表的数据元素，通过指针链接各元素。</p><p><strong>存储特点</strong>：</p><ul><li>逻辑上相邻的元素在物理上不一定相邻</li><li>只能顺序访问，不支持随机访问</li><li>存储密度小于1（需要额外存储指针）</li></ul><h4 id="2-2-2-链表的分类"><a href="#2-2-2-链表的分类" class="headerlink" title="2.2.2 链表的分类"></a>2.2.2 链表的分类</h4><table><thead><tr><th>链表类型</th><th>结构特点</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>单链表</strong></td><td>每个节点只有一个指针域</td><td>实现简单，空间开销小</td><td>只能单向遍历</td><td>一般的线性表操作</td></tr><tr><td><strong>双链表</strong></td><td>每个节点有前驱和后继指针</td><td>可双向遍历，删除方便</td><td>空间开销大</td><td>需要双向操作的场景</td></tr><tr><td><strong>循环链表</strong></td><td>尾节点指向头节点</td><td>便于循环操作</td><td>实现稍复杂</td><td>循环处理的应用</td></tr><tr><td><strong>静态链表</strong></td><td>用数组模拟链表结构</td><td>不需要指针，便于调试</td><td>容量固定</td><td>不支持指针的语言</td></tr></tbody></table><h4 id="2-2-3-链表的基本操作及复杂度"><a href="#2-2-3-链表的基本操作及复杂度" class="headerlink" title="2.2.3 链表的基本操作及复杂度"></a>2.2.3 链表的基本操作及复杂度</h4><table><thead><tr><th>操作类型</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th><th>空间复杂度</th><th>操作特点</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要先定位到位置</td></tr><tr><td><strong>删除</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要先定位到位置</td></tr><tr><td><strong>按位查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序遍历</td></tr><tr><td><strong>按值查找</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>需要顺序遍历</td></tr></tbody></table><h3 id="2-3-顺序表与链表的比较"><a href="#2-3-顺序表与链表的比较" class="headerlink" title="2.3 顺序表与链表的比较"></a>2.3 顺序表与链表的比较</h3><h4 id="2-3-1-性能对比"><a href="#2-3-1-性能对比" class="headerlink" title="2.3.1 性能对比"></a>2.3.1 性能对比</h4><table><thead><tr><th>比较维度</th><th>顺序表</th><th>链表</th><th>选择建议</th></tr></thead><tbody><tr><td><strong>存储密度</strong></td><td>高（&#x3D;1）</td><td>低（&lt;1）</td><td>空间要求高选顺序表</td></tr><tr><td><strong>随机访问</strong></td><td>支持，O(1)</td><td>不支持，O(n)</td><td>需要随机访问选顺序表</td></tr><tr><td><strong>插入删除</strong></td><td>平均O(n)，需移动元素</td><td>平均O(n)，但不移动元素</td><td>频繁插删选链表</td></tr><tr><td><strong>内存分配</strong></td><td>连续分配</td><td>离散分配</td><td>内存紧张选顺序表</td></tr><tr><td><strong>缓存性能</strong></td><td>好（局部性原理）</td><td>差（指针跳转）</td><td>性能要求高选顺序表</td></tr></tbody></table><h4 id="2-3-2-应用场景选择"><a href="#2-3-2-应用场景选择" class="headerlink" title="2.3.2 应用场景选择"></a>2.3.2 应用场景选择</h4><table><thead><tr><th>应用特点</th><th>推荐存储结构</th><th>理由说明</th></tr></thead><tbody><tr><td>表长基本稳定，查找频繁</td><td>顺序表</td><td>随机访问优势明显</td></tr><tr><td>表长变化大，插删频繁</td><td>链表</td><td>避免大量元素移动</td></tr><tr><td>对存储空间要求严格</td><td>顺序表</td><td>存储密度高，无额外指针开销</td></tr><tr><td>需要双向遍历</td><td>双链表</td><td>支持前驱访问</td></tr><tr><td>实现简单，开发效率优先</td><td>顺序表</td><td>实现和调试相对简单</td></tr></tbody></table><h2 id="三、线性表的应用与算法复杂度分析"><a href="#三、线性表的应用与算法复杂度分析" class="headerlink" title="三、线性表的应用与算法复杂度分析"></a>三、线性表的应用与算法复杂度分析</h2><p>理解线性表不仅要掌握其理论定义和基本操作，更要能在实际问题中根据性能需求选择合适的存储结构。本章将深入探讨顺序表和链表的算法复杂度，并结合典型应用场景进行分析。</p><h3 id="3-1-核心操作复杂度对比"><a href="#3-1-核心操作复杂度对比" class="headerlink" title="3.1 核心操作复杂度对比"></a>3.1 核心操作复杂度对比</h3><h4 id="3-1-1-时间复杂度分析"><a href="#3-1-1-时间复杂度分析" class="headerlink" title="3.1.1 时间复杂度分析"></a>3.1.1 时间复杂度分析</h4><table><thead><tr><th align="left">操作类型</th><th align="left">顺序表 (平均)</th><th align="left">顺序表 (最坏)</th><th align="left">链表 (平均)</th><th align="left">链表 (最坏)</th><th align="left">关键影响因素</th></tr></thead><tbody><tr><td align="left"><strong>按位查找 (GetElem)</strong></td><td align="left"><strong>O(1)</strong></td><td align="left">O(1)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：基于地址偏移计算，与位置无关。<br><strong>链表</strong>：需从头节点开始顺序遍历。</td></tr><tr><td align="left"><strong>按值查找 (LocateElem)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">无论顺序表还是链表，都需要逐一比较元素值。</td></tr><tr><td align="left"><strong>插入 (Insert)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：主要开销在于移动插入位置后的所有元素。<br><strong>链表</strong>：主要开销在于查找到插入位置的前驱节点。</td></tr><tr><td align="left"><strong>删除 (Delete)</strong></td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left">O(n)</td><td align="left"><strong>顺序表</strong>：主要开销在于移动删除位置后的所有元素。<br><strong>链表</strong>：主要开销在于查找到待删除节点的前驱节点。</td></tr><tr><td align="left"><strong>在指定节点后插入</strong></td><td align="left">-</td><td align="left">-</td><td align="left"><strong>O(1)</strong></td><td align="left">O(1)</td><td align="left"><strong>链表</strong>：若已持有前驱节点的指针，则插入操作仅需修改指针，与表长无关。</td></tr><tr><td align="left"><strong>删除指定节点</strong></td><td align="left">-</td><td align="left">-</td><td align="left"><strong>O(1)</strong> (双链表) &#x2F; O(n) (单链表)</td><td align="left">O(1) &#x2F; O(n)</td><td align="left"><strong>双链表</strong>：若持有待删除节点的指针，可直接获取前驱，O(1)完成。<br><strong>单链表</strong>：仍需O(n)查找前驱。</td></tr></tbody></table><p><strong>核心结论</strong>：</p><ul><li><strong>随机访问</strong>是顺序表的核心优势。</li><li><strong>插入&#x2F;删除</strong>的效率取决于<strong>查找</strong>的效率。链表在<strong>已知节点</strong>的情况下进行插入&#x2F;删除操作具有巨大优势。</li></ul><h4 id="3-1-2-空间复杂度分析"><a href="#3-1-2-空间复杂度分析" class="headerlink" title="3.1.2 空间复杂度分析"></a>3.1.2 空间复杂度分析</h4><table><thead><tr><th align="left">存储结构</th><th align="left">空间复杂度</th><th align="left">存储密度</th><th align="left">内存分配特点</th></tr></thead><tbody><tr><td align="left"><strong>顺序表</strong></td><td align="left"><strong>O(n)</strong></td><td align="left"><strong>1</strong></td><td align="left"><strong>整块分配</strong>：需要一块连续的内存空间，可能会因容量不足导致频繁的内存重分配和数据复制。</td></tr><tr><td align="left"><strong>链表</strong></td><td align="left"><strong>O(n)</strong></td><td align="left"><strong>&lt; 1</strong></td><td align="left"><strong>离散分配</strong>：每个节点独立分配内存，通过指针连接。空间利用率更高，但有额外的指针开销。</td></tr></tbody></table><h3 id="3-2-典型应用场景分析"><a href="#3-2-典型应用场景分析" class="headerlink" title="3.2 典型应用场景分析"></a>3.2 典型应用场景分析</h3><h4 id="3-2-1-顺序表的应用场景"><a href="#3-2-1-顺序表的应用场景" class="headerlink" title="3.2.1 顺序表的应用场景"></a>3.2.1 顺序表的应用场景</h4><p>顺序表凭借其<strong>O(1)的随机访问</strong>能力和<strong>良好的缓存局部性</strong>，在以下场景中表现出色：</p><table><thead><tr><th align="left">应用领域</th><th align="left">具体案例</th><th align="left">优势分析</th></tr></thead><tbody><tr><td align="left"><strong>科学计算与数据分析</strong></td><td align="left"><strong>矩阵&#x2F;向量运算</strong>、<strong>NumPy&#x2F;Pandas库</strong></td><td align="left">底层采用连续内存数组，完美契合CPU缓存机制，数值计算和数据处理性能极高。</td></tr><tr><td align="left"><strong>高效查找算法</strong></td><td align="left"><strong>二分查找</strong>、<strong>哈希表（开放地址法）</strong></td><td align="left">这些算法都要求能够快速访问任意位置的元素，顺序表是其实现的天然基础。</td></tr><tr><td align="left"><strong>CPU缓存与内存管理</strong></td><td align="left"><strong>高速缓存行 (Cache Line)</strong></td><td align="left">CPU从内存加载数据时，会一次性加载一个连续的数据块（缓存行），顺序表的物理连续性使其缓存命中率远高于链表。</td></tr><tr><td align="left"><strong>作为其他数据结构的底层实现</strong></td><td align="left"><strong>堆（Heap）</strong>、<strong>哈希表</strong></td><td align="left">完全二叉树（堆的逻辑结构）可以用数组完美表示，利用索引即可计算父子关系，无需指针。</td></tr></tbody></table><h4 id="3-2-2-链表的应用场景"><a href="#3-2-2-链表的应用场景" class="headerlink" title="3.2.2 链表的应用场景"></a>3.2.2 链表的应用场景</h4><p>链表的核心优势在于<strong>高效的、动态的插入和删除操作</strong>，尤其适用于表长频繁变化或需要高效节点操作的场景。</p><table><thead><tr><th align="left">应用领域</th><th align="left">具体案例</th><th align="left">优势分析</th></tr></thead><tbody><tr><td align="left"><strong>操作系统</strong></td><td align="left"><strong>进程管理</strong>、<strong>文件系统</strong></td><td align="left">进程的创建和销毁、空闲磁盘块的管理，都涉及频繁的、动态的插入和删除，链表是理想选择。</td></tr><tr><td align="left"><strong>内存管理</strong></td><td align="left"><strong>内存池 (Memory Pool)</strong>、<strong>伙伴系统 (Buddy System)</strong></td><td align="left">用于管理空闲内存块，当程序申请或释放内存时，可以高效地从链表中添加或移除相应大小的内存块。</td></tr><tr><td align="left"><strong>数据结构实现</strong></td><td align="left"><strong>图的邻接表</strong>、<strong>哈希表（拉链法）</strong></td><td align="left">当图的顶点度数差异很大时，邻接表（由链表数组构成）能有效节省空间。拉链法解决哈希冲突时，每个桶位都是一个链表。</td></tr><tr><td align="left"><strong>缓存淘汰算法</strong></td><td align="left"><strong>LRU (Least Recently Used) 缓存</strong></td><td align="left">LRU要求能快速将最新访问的元素移到表头，并淘汰表尾元素。使用<strong>双向链表</strong>配合哈希表，可实现O(1)时间的访问和淘汰操作。</td></tr></tbody></table><h4 id="3-2-3-案例研究：LRU缓存淘汰算法"><a href="#3-2-3-案例研究：LRU缓存淘汰算法" class="headerlink" title="3.2.3 案例研究：LRU缓存淘汰算法"></a>3.2.3 案例研究：LRU缓存淘汰算法</h4><p><strong>问题描述</strong>：设计一个容量有限的缓存，当缓存满时，需要淘汰最近最少使用的数据。</p><p><strong>解决方案</strong>：使用一个<strong>哈希表 (HashMap)</strong> 和一个<strong>双向链表 (Doubly Linked List)</strong>。</p><ul><li><strong>哈希表</strong>：存储键 (key) 到双向链表节点 (Node) 的映射，实现O(1)时间的快速查找。</li><li><strong>双向链表</strong>：维护数据的“新鲜度”。链表头部是最新访问的，尾部是最久未访问的。</li></ul><table><thead><tr><th align="left">操作</th><th align="left">实现流程</th><th align="left">复杂度</th></tr></thead><tbody><tr><td align="left"><strong>访问数据 (get)</strong></td><td align="left">1. 通过哈希表找到节点。<br>2. 将该节点从链表中移动到头部。<br>3. 返回节点值。</td><td align="left"><strong>O(1)</strong></td></tr><tr><td align="left"><strong>插入数据 (put)</strong></td><td align="left">1. <strong>若已存在</strong>：更新值，并将节点移到链表头部。<br>2. <strong>若不存在</strong>：<br>a. 创建新节点，插入链表头部。<br>b. 在哈希表中添加映射。<br>c. <strong>若缓存已满</strong>：删除链表尾部节点，并从哈希表中移除对应映射。</td><td align="left"><strong>O(1)</strong></td></tr></tbody></table><p><strong>为什么是双向链表？</strong><br>因为在移动或删除节点时，需要同时修改其<strong>前驱节点</strong>和<strong>后继节点</strong>的指针。双向链表可以在O(1)时间内完成这些操作，而单链表则需要O(n)时间来查找前驱节点。</p><h3 id="3-3-存储结构选择策略"><a href="#3-3-存储结构选择策略" class="headerlink" title="3.3 存储结构选择策略"></a>3.3 存储结构选择策略</h3><table><thead><tr><th align="left">决策依据</th><th align="left">优先选择顺序表</th><th align="left">优先选择链表</th></tr></thead><tbody><tr><td align="left"><strong>核心操作</strong></td><td align="left"><strong>查找&#x2F;访问</strong> 操作远多于插入&#x2F;删除</td><td align="left"><strong>插入&#x2F;删除</strong> 操作远多于查找&#x2F;访问</td></tr><tr><td align="left"><strong>表长变化</strong></td><td align="left">表长基本固定或变化不大</td><td align="left">表长频繁变化，难以预估</td></tr><tr><td align="left"><strong>内存要求</strong></td><td align="left">内存空间有限，要求<strong>高存储密度</strong></td><td align="left">内存空间充裕，可接受指针开销</td></tr><tr><td align="left"><strong>性能要求</strong></td><td align="left">追求极致的<strong>缓存性能</strong>和计算速度</td><td align="left">对随机访问性能要求不高</td></tr></tbody></table><h2 id="四、常见面试题与解题思路"><a href="#四、常见面试题与解题思路" class="headerlink" title="四、常见面试题与解题思路"></a>四、常见面试题与解题思路</h2><p>本章将精选关于线性表的常见面试题，提供详细的解题思路、多种实现方法以及完整的C++代码，帮助你巩固知识，从容应对面试。</p><h3 id="4-1-单链表反转"><a href="#4-1-单链表反转" class="headerlink" title="4.1 单链表反转"></a>4.1 单链表反转</h3><p><strong>问题描述</strong>：给定一个单链表的头节点，将其反转，并返回反转后链表的头节点。</p><p><strong>解题思路</strong>：<br>这是链表操作中最经典、最基础的题目之一。核心思想是改变节点的<code>next</code>指针的指向，使其指向其前一个节点。</p><ul><li><p><strong>迭代法</strong>：推荐使用此方法，因为它空间复杂度为O(1)，且逻辑清晰。需要三个指针：</p><ul><li><code>pre</code>：指向当前节点的前一个节点，初始为<code>nullptr</code>。</li><li><code>cur</code>：指向当前正在处理的节点，初始为<code>head</code>。</li><li><code>next</code>：临时保存当前节点的下一个节点，防止链表断裂。</li></ul><p>遍历链表，依次将<code>cur</code>的<code>next</code>指针指向<code>pre</code>，然后同步向后移动<code>pre</code>和<code>cur</code>。</p></li><li><p><strong>递归法</strong>：思路更巧妙，但空间复杂度为O(n)，且可能因递归深度过大导致栈溢出。</p><ul><li>递归的终止条件是链表为空或只有一个节点。</li><li>递归调用<code>reverseList(head-&gt;next)</code>，得到反转后的子链表的头节点<code>newHead</code>。</li><li>将<code>head-&gt;next</code>的<code>next</code>指针指向<code>head</code>，再将<code>head</code>的<code>next</code>指针设为<code>nullptr</code>。</li></ul></li></ul><p><strong>C++ 代码实现 (迭代法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = cur-&gt;next; <span class="comment">// 临时保存下一个节点</span></span><br><span class="line">            cur-&gt;next = pre;               <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">            pre = cur;                     <span class="comment">// pre后移</span></span><br><span class="line">            cur = nextTemp;                <span class="comment">// cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// 返回新的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-环形链表检测"><a href="#4-2-环形链表检测" class="headerlink" title="4.2 环形链表检测"></a>4.2 环形链表检测</h3><p><strong>问题描述</strong>：给定一个链表，判断链表中是否有环。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>哈希表法</strong>：遍历链表，将每个访问过的节点的地址存入哈希表中。如果遇到一个节点已存在于哈希表中，说明链表有环。时间复杂度O(n)，空间复杂度O(n)。</p></li><li><p><strong>快慢指针法（Floyd判圈算法）</strong>：最优解法。定义两个指针<code>slow</code>和<code>fast</code>，都从头节点出发。</p><ul><li><code>slow</code>每次走一步。</li><li><code>fast</code>每次走两步。</li><li>如果链表中存在环，<code>fast</code>指针最终会从后面追上<code>slow</code>指针，两者相遇。如果<code>fast</code>或<code>fast-&gt;next</code>到达<code>nullptr</code>，则说明无环。</li></ul></li></ul><p><strong>C++ 代码实现 (快慢指针法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 快指针到达终点，无环</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 快慢指针相遇，有环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-3-合并两个有序链表"><a href="#4-3-合并两个有序链表" class="headerlink" title="4.3 合并两个有序链表"></a>4.3 合并两个有序链表</h3><p><strong>问题描述</strong>：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>迭代法</strong>：创建一个哑节点（dummy node）作为新链表的头，简化边界处理。使用一个指针<code>cur</code>指向新链表的尾部。比较两个链表的当前节点值，将较小的节点连接到<code>cur</code>后面，然后移动相应链表的指针和<code>cur</code>指针。当一个链表遍历完后，将另一个链表余下的部分直接拼接到新链表末尾。</p></li><li><p><strong>递归法</strong>：比较两个链表的头节点<code>l1</code>和<code>l2</code>。</p><ul><li>若<code>l1-&gt;val &lt; l2-&gt;val</code>，则<code>l1</code>为新链表的头，其<code>next</code>指针指向<code>mergeTwoLists(l1-&gt;next, l2)</code>的结果。</li><li>否则，<code>l2</code>为新链表的头，其<code>next</code>指针指向<code>mergeTwoLists(l1, l2-&gt;next)</code>的结果。</li><li>递归终止条件是任一链表为空。</li></ul></li></ul><p><strong>C++ 代码实现 (迭代法)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 创建哑节点</span></span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接剩余部分</span></span><br><span class="line">        cur-&gt;next = (l1 != <span class="literal">nullptr</span>) ? l1 : l2;</span><br><span class="line"></span><br><span class="line">        ListNode* head = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy; <span class="comment">// 释放哑节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除链表的倒数第-N-个结点"><a href="#4-4-删除链表的倒数第-N-个结点" class="headerlink" title="4.4 删除链表的倒数第 N 个结点"></a>4.4 删除链表的倒数第 N 个结点</h3><p><strong>问题描述</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>解题思路</strong>：</p><ul><li><p><strong>快慢指针法</strong>：这是解决此类问题的经典方法。定义<code>fast</code>和<code>slow</code>两个指针。</p><ol><li>让<code>fast</code>指针先从头节点走 <code>n</code> 步。</li><li>然后<code>fast</code>和<code>slow</code>指针同时向后走，直到<code>fast</code>指针到达链表末尾（<code>fast-&gt;next == nullptr</code>）。</li><li>此时，<code>slow</code>指针正好指向倒数第 <code>n+1</code> 个节点，即待删除节点的前一个节点。</li><li>修改<code>slow</code>的<code>next</code>指针，<code>slow-&gt;next = slow-&gt;next-&gt;next</code>，即可删除目标节点。</li></ol></li><li><p><strong>注意边界情况</strong>：如果删除的是头节点（即<code>n</code>等于链表长度），<code>fast</code>走完<code>n</code>步后会是<code>nullptr</code>。此时直接返回<code>head-&gt;next</code>即可。为了统一处理，可以引入哑节点。</p></li></ul><p><strong>C++ 代码实现 (快慢指针 + 哑节点)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快指针先走 n 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">ß</span><br><span class="line">        <span class="comment">// 2. 快慢指针同时走，直到快指针到达末尾</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 删除目标节点</span></span><br><span class="line">        ListNode* toDelete = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://polarwanderer.cn/2025/03/25/1558/" data-id="cmfku2n73000j4kzbhxspeivb" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABxUlEQVR42u3aQY6DMAwF0N7/0sx6hAjfDkmL9LJCLSQvLKzY5vOJx3Eavd/Pc35WDFxc3GnuMRzne64WG+Oq27ucDRcXdyN3HGjGuPFmrhYez3/5Oy4u7k9yc1xvBlxc3Ldzq8ELFxf3Xdz8yJIkM3k1Y2GuhouLO8HNq5TrrpfUd3FxcVvcoziqpZNqSeVmdVxc3C3cPKBUjzLVgJisi4uLu4ebNErHLZDxU72NFUIYLi7uAm41CckLoL1Wa1JAwcXFXc2daZD07qwmSP+ucXFxN3KrISbfXq/meZP84OLibuT2PrrKE5jkdUS5Gi4u7mJuder844leICvUd3FxcZdx59OSJAAlBdZoBlxc3I3cJBjNL9k7MJULpri4uNPcaqO0GqTyo0/5Ew1cXNzF3F7Q6X1mUW3ERrUcXFzcLdy8mTrTaMnLK7i4uN/lzpREq0GteQ8uLu5i7lEceeHjqVeAi4u7n5uPHJGHrfzYVN4MLi7uNDcPOnmrNXk3eYDDxcX9FjcPNNVyyZJcDRcX98e4zyZUzYwNFxf3hdzkw45q6oWLi7uf2ytu5tf5szf/4uLibuH2wlO1TZsEu4fru7i4uB3uHyJ4SOdD+n0MAAAAAElFTkSuQmCC">Share</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a></li></ul></div><div class="post-nav"><a class="pre" href="/2025/06/22/0218/">计算机网络-传输层</a><a class="next" href="/2025/03/25/1556/">数据结构-基本概念</a></div><div class="nofancybox" id="waline"></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/@waline/client@v3/dist/waline.css"><script type="module">import{init}from"https://unpkg.com/@waline/client@v3/dist/waline.js";init({el:"#waline",comment:!0,serverURL:"comments.polarwanderer.cn",pageSize:"8",wordLimit:"120",requiredMeta:requiredMeta,emoji:["//unpkg.com/@waline/emojis@1.2.0/weibo","//unpkg.com/@waline/emojis@1.2.0/qq","//unpkg.com/@waline/emojis@1.2.0/tw-emoji"]})</script><script>let metaInfo=["nick","mail","link"],requiredMeta="nick,mail".split(",").filter(i=>metaInfo.indexOf(i)>-1)</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0" readonly></div></div><div class="search-modal" id="search-modal"><div class="search-modal-content"><div class="search-modal-header"><input class="search-modal-input" id="modal-search-input" placeholder="输入关键词搜索..." type="text" name="q"></div><div class="search-modal-body"><div id="modal-search-result"></div></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o">Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o">Tags</i></div><div class="tagcloud"><a href="/tags/408/" style="font-size:15px">408</a> <a href="/tags/%E4%BA%92%E8%81%94%E7%BD%91/" style="font-size:15px">互联网</a> <a href="/tags/%E4%BA%BA%E7%89%A9/" style="font-size:15px">人物</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:15px">历史</a> <a href="/tags/%E5%93%B2%E5%AD%A6/" style="font-size:15px">哲学</a> <a href="/tags/%E5%9B%9E%E5%BF%86/" style="font-size:15px">回忆</a> <a href="/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" style="font-size:15px">年终总结</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size:15px">思考</a> <a href="/tags/%E6%84%9F%E6%82%9F/" style="font-size:15px">感悟</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:15px">数学建模</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:15px">数据结构</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:15px">机器学习</a> <a href="/tags/%E6%A2%A6%E5%A2%83/" style="font-size:15px">梦境</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:15px">生活</a> <a href="/tags/%E7%A4%BE%E4%BC%9A%E7%8E%B0%E8%B1%A1/" style="font-size:15px">社会现象</a> <a href="/tags/%E7%AB%9E%E8%B5%9B/" style="font-size:15px">竞赛</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size:15px">笔记</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size:15px">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size:15px">网络层</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size:15px">计算机网络</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94/" style="font-size:15px">计算机考研</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size:15px">记录</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:15px">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o">Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/09/15/1524/">高级软件工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/22/0218/">计算机网络-传输层</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/1558/">数据结构-线性表</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/25/1556/">数据结构-基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/03/24/2121/">计算机网络-网络层</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/29/0021/">浪迹天涯</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/07/08/2317/">寻书</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/25/2338/">半年志</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/02/07/2150/">2024年美赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/12/31/2342/">抓住2023的小尾巴</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o">Recent Comments</i></div><div id="widget-waline-list"></div><script type="text/javascript" id="recent-comment" serverurl="comments.polarwanderer.cn" count="5" src="/js/recent-comments.js?v=1.0.0" async></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022-2025 <a href="/." rel="nofollow">BlankChen.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;searchFunc(path,"local-search-input","local-search-result")</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script><script type="text/javascript" src="/js/sticky-header.js?v=1.0.0"></script><script type="text/javascript" src="/js/toc-generator.js?v=1.0.0"></script><script type="text/javascript" src="/js/snowfall.js?v=1.0.0"></script><script type="text/javascript" src="/js/text-reader.js?v=1.0.0"></script><script type="text/javascript" src="/js/floating-buttons.js?v=1.0.0"></script><script type="text/javascript" src="/js/random-post.js?v=1.0.0"></script><script type="text/javascript" src="/js/thoughts-typewriter.js?v=1.0.0"></script><script type="text/javascript" src="/js/subtitle-typewriter.js?v=1.0.0"></script></div></body></html>